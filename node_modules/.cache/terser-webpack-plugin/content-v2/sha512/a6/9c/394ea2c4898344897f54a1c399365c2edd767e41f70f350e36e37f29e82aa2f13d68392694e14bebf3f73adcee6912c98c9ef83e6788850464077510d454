{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{365:function(n,e,t){\"use strict\";t.r(e);var r=t(44),i=Object(r.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[t(\"p\",[n._v('1、String\\n• 声明为final，不可被继承，最终类\\n• 是一个不可变的字符串，因为底层char [] 也被final修改\\n• 一旦一个string对象在内存(堆)中被创建出来，他就无法被修改。特别要注意的是，String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。\\n• 常量与常量的拼接结果在常量池，且常量池中不会存在相同内容的常量\\n• 只要其中有一个变量，结果就在堆中\\n• 如果拼接的结果调用intern()方法，返回值就在常量池中\\nString对\"+\"的重载')]),n._v(\" \"),t(\"ol\",[t(\"li\",[t(\"p\",[n._v('String s = \"a\" + \"b\"，编译器会进行常量折叠(因为两个都是编译期常量，编译期可知)，即变成 String s = \"ab\"')])]),n._v(\" \"),t(\"li\",[t(\"p\",[n._v('对于能够进行优化的(String s = \"a\" + 变量 等)用 StringBuilder 的 append() 方法替代，最后调用 toString() 方法 (底层就是一个 new String())\\nStringBuffer和StringBuilder\\n接下来我们看看StringBuffer和StringBuilder的实现原理。\\n和String类类似，StringBuilder类也封装了一个字符数组，定义如下：\\nchar[] value;\\n与String不同的是，它并不是final的，所以他是可以修改的。另外，与String不同，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数，定义如下：\\nint count;\\n其append源码如下：\\npublic StringBuilder append(String str) {\\nsuper.append(str);\\nreturn this;\\n}\\n该类继承了AbstractStringBuilder类，看下其append方法：\\npublic AbstractStringBuilder append(String str) {\\nif (str == null)\\nreturn appendNull();\\nint len = str.length();\\nensureCapacityInternal(count + len);\\nstr.getChars(0, len, value, count);\\ncount += len;\\nreturn this;\\n}\\nappend会直接拷贝字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。\\nStringBuffer和StringBuilder类似，最大的区别就是StringBuffer是线程安全的，看一下StringBuffer的append方法。\\npublic synchronized StringBuffer append(String str) {\\ntoStringCache = null;\\nsuper.append(str);\\nreturn this;\\n}\\n该方法使用synchronized进行声明，说明是一个线程安全的方法。而StringBuilder则不是线程安全的。\\nString、StringBuffer、StirngBuilder三者的异同：\\nString：不可变的字符序列，底层使用char[]存储\\nStringBuffer:可变的字符序列，线程安全的，效率低；底层使用char[]存储\\nStringBuilder：可变的字符序列，JDK5.0新增的，线程不安全，效率高；底层使用char[]存储\\n总结\\n本文介绍了什么是字符串拼接，虽然字符串是不可变的，但是还是可以通过新建字符串的方式来进行字符串的拼接。\\n常用的字符串拼接方式有五种，分别是使用+、使用concat、使用StringBuilder、使用StringBuffer以及使用StringUtils.join。\\n由于字符串拼接过程中会创建新的对象，所以如果要在一个循环体中进行字符串拼接，就要考虑内存问题和效率问题。\\n因此，经过对比，我们发现，直接使用StringBuilder的方式是效率最高的。因为StringBuilder天生就是设计来定义可变字符串和字符串的变化操作的。\\n但是，还要强调的是：\\n• 如果不是在循环体中进行字符串拼接的话，直接使用+就好了。\\n• 如果在并发场景中进行字符串拼接的话，要使用StringBuffer来代替StringBuilder。\\n• 字符串有长度限制，在编译期，要求字符串常量池中的常量不能超过65535，并且在javac执行过程中控制了最大值为65534。\\n• 在运行期，长度不能超过Int的范围，否则会抛异常。\\n2、Java比较器接口\\n• comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序\\n• comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序\\n自然排序：Comparable\\n重写compareTo(obj)的规则:\\n• 如果当前对象this大于形参对象obj，则返回正整数\\n• 如果当前对象this小于形参对象obj，则返回负数\\n• 如果当前对象this等于形参对象obj，则返回零\\n对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法\\n定制排序：Comparator\\n如果对于类不能修改其结构（比如不能重写compare方法），又或者实现Comparable不合适，就可以自定义排序规则，就使用Comparator\\n3、枚举类\\npublic enum  Season {\\nSPRING(\"春天\",1);')]),n._v(\" \"),t(\"p\",[n._v('private String name;\\nprivate int code;\\nprivate Season(String name, int code) {\\nthis.name = name;\\nthis.code = code;\\n}\\nprivate String getName() {\\nreturn name;\\n}\\npublic int getCode() {\\nreturn code;\\n}\\n}\\n可以实现一个自定义的接口，并且在每个对象里面重写该接口的方法，来达到对象的方法的不同操作\\npublic enum  Season implements Show{\\nSPRING(\"春天\",1){\\n@Override\\npublic void show() {\\nSystem.out.println(\"每个对象都可以自定义实现show()\");\\n}\\n};\\nprivate String name;\\nprivate int code;\\nprivate Season(String name, int code) {\\nthis.name = name;\\nthis.code = code;\\n}\\nprivate String getName() {\\nreturn name;\\n}\\npublic int getCode() {\\nreturn code;\\n}\\n}\\ninterface Show{\\nvoid show();\\n}\\n4、注解\\nAnnotation的成员变量在Annotation 定义中以无参的方法的形式来声明的，其方法名和返回值定义了该成员的名字和类型，我们称为配置参数\\n注解类型\\n• 八种基本数据类型\\n• String类型\\n• Class类型\\n• enum类型\\n• Annotation类型\\n• 以上类型的一维数组\\n注解的作用\\n• 注解就像标签，是程序判断执行的依据。比如，程序读到@Test就知道这个方法是待测试方法，而@Before的方法要在测试方法之前执行\\n• 注解需要三要素：定义、使用、读取并执行\\n• 注解分为自定义注解、JDK内置注解和第三方注解（框架）。自定义注解一般要我们自己定义、使用、并写程序读取，而JDK内置注解和第三方注解我们只要使用，定义和读取都交给它们\\nJDK内置3个注解：\\n@Override:重写的父类的方法\\n@Deprecated:用于修饰类，方法已经过时\\n@SuppressWarning:抑制编译器警告\\n原注解\\n说简单点，就是 定义其他注解的注解 。 比如Override这个注解，就不是一个元注解。而是通过元注解定义出来的。\\n@Target(ElementType.METHOD)\\n@Retention(RetentionPolicy.SOURCE)\\npublic @interface Override {')])])]),n._v(\" \"),t(\"p\",[n._v(\"}\\n这里面的 @Target @Retention 就是元注解。\\n元注解有六个:\\n@Target（表示该注解可以用于什么地方）\\n@Retention（表示再什么级别保存该注解信息）\\n@Documented（将此注解包含再javadoc中）\\n@Inherited（允许子类继承父类中的注解）\\n@Repeatable（1.8新增，允许一个注解在一个元素上使用多次）\\n@Native（1.8新增，修饰成员变量，表示这个变量可以被本地代码引用，常常被代码生成工具使用）。\\n如何自定义注解\\n在Java中，类使用class定义，接口使用interface定义，注解和接口的定义差不多，增加了一个@符号，即@interface，代码如下：\\n• 注解声明为：@interface\\n• 内部定义成员，通常使用value表示\\n• 可以指定成员的默认值，使用default定义\\n• 如果自定义的注解没有，表示是一个表示作用\\n• 自定义注解必须配上注解信息处理流程才有意义--使用反射\\npublic @interface EnableAuth {\")]),n._v(\" \"),t(\"p\",[n._v(\"}\\n注解中可以定义成员变量，用于信息的描述，跟接口中方法的定义类似，代码如下：\\npublic @interface EnableAuth {\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",[t(\"code\",[n._v(\"String name();\\n\")])])]),t(\"p\",[n._v(\"}\\n还可以添加默认值：\\npublic @interface EnableAuth {\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",[t(\"code\",[n._v('String name() default \"猿天地\";\\n')])])]),t(\"p\",[n._v(\"}\\n上面的介绍只是完成了自定义注解的第一步，开发中日常使用注解大部分是用在类上，方法上，字段上，示列代码如下：\\n@Target(ElementType.METHOD)\\n@Retention(RetentionPolicy.RUNTIME)\\n@Documented\\npublic @interface EnableAuth {\")]),n._v(\" \"),t(\"p\",[n._v(\"}\\nTarget\\n用于指定被修饰的注解修饰哪些程序单元，也就是上面说的类，方法，字段\\nRetention\\n用于指定被修饰的注解被保留多长时间\\nSOURCE（注解仅存在于源码中，在class字节码文件中不包含）\\nCLASS（默认的保留策略，注解会在class字节码文件中存在，但运行时无法获取）\\nRUNTIME（注解会在class字节码文件中存在，在运行时可以通过反射获取到）\\n三种类型，如果想要在程序运行过程中通过反射来获取注解的信息需要将Retention设置为RUNTIME\\nDocumented\\n用于指定被修饰的注解类将被javadoc工具提取成文档\\nInherited\\n用于指定被修饰的注解类将具有继承性\")])])}),[],!1,null,null,null);e.default=i.exports}}]);","extractedComments":[]}