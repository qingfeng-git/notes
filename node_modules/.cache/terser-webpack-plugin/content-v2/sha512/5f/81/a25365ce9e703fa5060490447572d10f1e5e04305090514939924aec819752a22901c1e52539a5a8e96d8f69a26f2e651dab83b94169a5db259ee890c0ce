{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{366:function(a,e,n){\"use strict\";n.r(e);var t=n(44),r=Object(t.a)({},(function(){var a=this,e=a.$createElement,n=a._self._c||e;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[n(\"p\",[a._v(\"大致说明：\\n看上面的框架图，先抓住它的主干，即 Collection 和 Map。\\n1、Collection 是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection 包含了 List 和 Set 两大分支。\\n• List 是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是 0。List 的实现类有 LinkedList, ArrayList, Vector, Stack。\\n• Set 是一个不允许有重复元素的集合。Set 的实现类有 HastSet 和 TreeSet。HashSet 依赖于 HashMap，它实际上是通过 HashMap 实现的；TreeSet 依赖于 TreeMap，它实际上是通过 TreeMap 实现的。\\n2、Map 是一个映射接口，即 key-value 键值对。Map 中的每一个元素包含 “一个 key” 和“key 对应的 value”。AbstractMap 是个抽象类，它实现了 Map 接口中的大部分 API。而 HashMap，TreeMap，WeakHashMap 都是继承于 AbstractMap。Hashtable 虽然继承于 Dictionary，但它实现了 Map 接口。\\n3、接下来，再看 Iterator。它是遍历集合的工具，即我们通常通过 Iterator 迭代器来遍历集合。我们说 Collection 依赖于 Iterator，是因为 Collection 的实现类都要实现 iterator() 函数，返回一个 Iterator 对象。ListIterator 是专门为遍历 List 而存在的。\\n4、再看 Enumeration，它是 JDK 1.0 引入的抽象类。作用和 Iterator 一样，也是遍历集合；但是 Enumeration 的功能要比 Iterator 少。在上面的框图中，Enumeration 只能在 Hashtable, Vector, Stack 中使用。\\n5、最后，看 Arrays 和 Collections。它们是操作数组、集合的两个工具类。\\n一、Collection体系 (接口)\"),n(\"br\"),a._v(\"\\n• 是单列集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素\\n• JDK不提供此接口的任何直接实现,它提供更具体的子接口(如Set和List)实现\\nCollection 接口是处理对象集合的根接口，其中定义了很多对元素进行操作的方法。Collection 接口有两个主要的子接口 List 和 Set\\n注意 Map 不是 Collection 的子接口，这个要牢记。\\ncollection接口定义的有几个比较常用的方法\\n• add() 添加一个元素到集合中\\n• addAll() 将指定集合中的所有元素添加到集合中\\n• contains()方法检测集合中是否包含指定的元素\\n• toArray() 方法返回一个表示集合的数组。\\n• 另外，Collection 中有一个iterator()函数，它的作用是返回一个 Iterator 接口。通常，我们通过 Iterator 迭代器来遍历集合。ListIterator 是 List 接口所特有的，在 List 接口中，通过ListIterator()返回一个 ListIterator 对象。\\n•\\n注意\\n• 向collection接口实现类的对象中添加数据obj时，要求obj所在类要重写equals()\\n• 集合到数组 --\\x3etoArray()\\n• 数组到集合 --\\x3eArrays.asList()\\nCollection 接口有两个常用的子接口(List,set)，下面详细介绍。\\nIterator接口\\n• 游标记录元素位置\\n• 作用就是遍历Collection集合的接口，又称为迭代器\\n• Collection接口继承了Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象\\n• Iterator仅用于遍历集合，Iterator本身并不提供承装对象的能力，如果需要创建Iterator对象，则必须有一个被迭代的集合\\n• 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前\\n• 内部定义可以在遍历的时候删除集合元素的方法remove() ，此方法不同于集合直接调用remove()方法\\n• 每调用一次next()方法，remove()方法只能被调用一次\\n• JDK5.0以后新增的foreach循环遍历元素，底层其实还是调用Iterator完成操作\\nListIterator\\n• ListIterator 是一个功能更加强大的迭代器, 它继承于 Iterator 接口，只能用于各种 List 类型的访问。\\n• 可以通过调用listIterator()方法产生一个指向 List 开始处的 ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为 n 的元素处的 ListIterator。\\n• 双向移动（向前 / 向后遍历）.\\n• 产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引.\\n• 可以使用set()方法替换它访问过的最后一个元素.\\n• 可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素.\\nList接口\\n• 元素存储有序\\n• 以存储重复元素\\n• 访问集合中的元素可以根据元素的索引来访问\\n• 是一个动态数组\\n• 可以包含null值\\n1.ArrayList\\n特点\\n• 底层是数组\\n• 存储有序，元素可重复\\n• 线程不安全，效率高\\n• 查询快，增删慢\\n注意\\nremove(int index)和remove(Object obj)前面是根据索引删元素，后面直接删对象元素\\nHere is yuque doc card, click on the link to view:https://www.yuque.com/zhaoqingfeng/fa26sm/vt74ww\\n2.LinkedList\\n特点\\n• 底层使用的是双向链表存储\\n• 存储有序，元素可重复\\n• 增删快，查询慢\\n• 线程不安全，效率高\\n• 此集合不涉及到扩容，只有数组才会扩容\\n3.Vector\\n特点\\n• 底层数组\\n• 存储有序，元素可重复\\n• 线程安全，效率低\\n• 同ArrayList扩容机制不同，默认是长度的2倍，而ArrayList则是1.5倍\\n4.Stack\\n• Stack 继承自 Vector\\n• 实现一个后进先出的堆栈\\n• Stack 提供 5 个额外的方法使得 Vector 得以被当作堆栈使用\\n基本的 push 和 pop 方法，还有 peek 方法得到栈顶的元素\\n• empty 方法测试堆栈是否为空\\n• search 方法检测一个元素在堆栈中的位置。Stack 刚创建后是空栈\\nSet接口\\n• 元素存储无序\\n• 不可存储重复元素\\n• 允许null存在，但只能有一个null值\\n• 元素在 set 中的位置是由该元素的 HashCode 决定的，其具体位置其实是固定的\\n• Set 集合中的去重和 hashcode 与 equals 方法直接相关\\n1.散列集 HashSet\\n• 元素不重复，无序，元素可以为null\\n• 无序性，不代表随机性\\n• 存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据hashcode()计算的值\\n• 底层是hashMap实现，Map层还是数组+链表，所以说它底层也是数组\\n• 线程不安全，底层是hash算法来计算存储地址，存取和查找效率高\\n添加元素的过程\\n我们向HashSet中添加元素a，首先调用元素a所在类的hashcode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中存放的位置(即为：索引位置)，判断数组此位置上是否已经有元素\\n• 如果此位置上没有其他元素，则元素a添加成功 ---\\x3e情况1\\n• 如果此位置上有其他元素b（或以链表的形式存在的多个元素），则比较元素a与元素b的hash值\\n• 如果hash值不相同，则元素a添加成功 ---\\x3e情况2\\n• 如果hash值相同，进而需要调用元素a所在类的equals()方法\\n• equals()返回ture，元素a添加失败\\n• equals()返回false，则元素a添加成功 ---\\x3e情况3\\n说明\\n对于添加成功的情况2和3而言，元素a，与已经存在指定索引位置上数据以链表的方式存储\\n• jdk1.7：元素a放到数组中，指向原来的元素\\n• jdk1.8：原来的元素在数组中，指向元素a\\n• 总结一句话：七上八下\\n2.链式散列集 LinkedHashSet\\n• 继承于HashSet\\n• 底层是基于 LinkedHashMap 来实现的\\n• 元素不重复\\n• LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据\\n• 对于频繁的遍历操作LinkedHashSet效率高于HashSet\\n3.树形集 TreeSet\\n• 底层是红黑树\\n• 向TreeSet中add()的数据，要求是相同的对象\\n• 可以按照添加的对象指定属性进行排序\"),n(\"br\"),a._v(\"\\n• 排序比较相同的时候不在是靠equals()方法了，而是compareTo()\\n• 依旧Comparable自然排序和Compartor定制排序\"),n(\"br\"),a._v('\\n二、Map体系(接口)\\n双列集合\\n集合中保存 Key-value 对形式的元素（键值对）\\n访问时只能根据每项元素的 key 来访问其 value\\nJDK1.8的底层数据结构图\\nJDK1.7没有红黑树，其他与1.8无异\\n1.HashMap\\n• 作为Map的一个主要实现\\n• 底层JDK7：数组+链表 / JDK8：数组+链表+红黑树\\n• 线程不安全,效率高\\n• 可以存储null的key和value\\n• key是无序的，不可重复，相当于使用Set存储所有的key（什么Map就对应这什么Set）\\n• value是无序的，可重复的，相当于使用Collection存储所有的value\\n• 一个键值对（k-v）构成了一个Entry对象 （JDK1.7是Entry，JDK1.8是Node）\\n• Entry无序的，不可重复，相当于使用Set存储\\n• 如果key是一个自定义的对象的话，一定要重写hashcode()和equals()方法\\nLinkedHashMap\\n• 保证遍历map元素时,可以按照我们添加的顺序来进行遍历,添加了指针,记录了前一个和后一个元素引用\\n• HashMap的子类\\n• 频繁的遍历的时候可以使用linkedHashMap\\n• 可以存储null的key和value\\n• 内部有一个Entry对象继承了HashMap的Node对象，Entry里面记录了添加是前后属性的引用，所以保证了输出时是按照添加的顺序输出\\n2.TreeMap\\n• 底层是红黑树\\n• 保证按照添加的key-value对 进行排序，实现排序遍历（按照key来排序的）\\n• key不能为null，value可以是null\\n• 可以自然排序和定制排序\\n3.Hashtable\\n• 底层数组+链表\\n• 线程安全,效率低\\n• 不能存储null的key和value\\n• 扩容机制:默认11容量,每次扩容2n+1\\n• 多线程环境下访问，也只对有一个线程对整个map进行操作，效率比较低，使用Conlections集合工具类同理\\nProperties\\n• Hashtable的子类\\n• 常用来处理配置文件\\n• key和value都是string类型的\\n• 方法load()加载一个流文件\\n三、线程安全的集合类\\nCollections工具类\\n它是操作Collection和Map的一个工具类\\nCollections类中提供了多个synchnizedXxx()方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全的问题\\n异同点\\n1.ArrayList 和 LinkedList\\n• ArrayList 是实现了基于动态数组的数据结构，LinkedList 基于链表的数据结构。\\n• 对于随机访问 get 和 set，ArrayList 绝对优于 LinkedList，因为 LinkedList 要移动指针。\\n• 对于新增和删除操作 add 和 remove，LinedList 比较占优势，因为 ArrayList 要移动数据。\\n这一点要看实际情况的。**若只对单条数据插入或删除，ArrayList 的速度反而优于 LinkedList。**但若是批量随机的插入删除数据，LinkedList 的速度大大优于 ArrayList. 因为 ArrayList 每插入一条数据，要移动插入点及之后的所有数据。\\n2.HashTable 与 HashMap\\n相同点：\\n• 都实现了Map、Cloneable、java.io.Serializable接口。\\n• 都是存储 \"键值对 (key-value)\" 的散列表，而且都是采用拉链法实现的。\\n不同点：\\n**（1）历史原因：**HashTable 是基于陈旧的 Dictionary 类的，HashMap 是 Java 1.2 引进的 Map 接口的一个实现 。\\n**（2）同步性：**HashTable 是线程安全的，也就是说是同步的，而 HashMap 是线程序不安全的，不是同步的 。\\n**（3）对 null 值的处理：**HashMap 的 key、value 都可为 null，HashTable 的 key、value 都不可为 null 。\\n**（4）基类不同：**HashMap 继承于 AbstractMap，而 Hashtable 继承于 Dictionary。\\n• Dictionary 是一个抽象类，它直接继承于 Object 类，没有实现任何接口。Dictionary 类是 JDK 1.0 的引入的。虽然 Dictionary 也支持 “添加 key-value 键值对”、“获取 value”、“获取大小” 等基本操作，但它的 API 函数比 Map 少；而且 Dictionary 一般是通过 Enumeration(枚举类)去遍历，Map 则是通过 Iterator(迭代 M 器)去遍历。然而由于 Hashtable 也实现了 Map 接口，所以，它即支持 Enumeration 遍历，也支持 Iterator 遍历。\\n• AbstractMap 是一个抽象类，它实现了 Map 接口的绝大部分 API 函数；为 Map 的具体实现类提供了极大的便利。它是 JDK 1.2 新增的类。\\n**（5）支持的遍历种类不同：**HashMap 只支持 Iterator(迭代器) 遍历。而 Hashtable 支持 Iterator(迭代器) 和 Enumeration(枚举器) 两种方式遍历。\\n3.HashMap、Hashtable、LinkedHashMap 和 TreeMap 比较\\nHashmap 是一个最常用的 Map，它根据键的 HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。**HashMap 最多只允许一条记录的键为 Null；允许多条记录的值为 Null；HashMap 不支持线程的同步，即任一时刻可以有多个线程同时写 HashMap；可能会导致数据的不一致。**如果需要同步，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有同步的能力。\\nHashtable 与 HashMap 类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写 Hashtable，因此也导致了 Hashtale 在写入时会比较慢。\\nLinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和容量无关，而 HashMap 的遍历速度和他的容量有关。\\n如果需要输出的顺序和输入的相同，那么用 LinkedHashMap 可以实现，它还可以按读取顺序来排列，像连接池中可以应用。LinkedHashMap 实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。对于 LinkedHashMap 而言，它继承与 HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类 HashMap 相似，它通过重写父类相关的方法，来实现自己的链接列表特性。\\n**TreeMap 实现 SortMap 接口，内部实现是红黑树。**能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。TreeMap 不允许 key 的值为 null。非同步的。\\n一般情况下，我们用的最多的是 HashMap，HashMap 里面存入的键值对在取出的时候是随机的，它根据键的 HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在 Map 中插入、删除和定位元素，HashMap 是最好的选择。\\nTreeMap 取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么 TreeMap 会更好。\\nLinkedHashMap 是 HashMap 的一个子类，如果需要输出的顺序和输入的相同，那么用 LinkedHashMap 可以实现，它还可以按读取顺序来排列，像连接池中可以应用。\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.LinkedHashMap;\\nimport java.util.TreeMap;\\npublic class MapTest {\\npublic static void main(String[] args) {\\n//HashMap\\nHashMap<String,String> hashMap = new HashMap();\\nhashMap.put(\"4\", \"d\");\\nhashMap.put(\"3\", \"c\");\\nhashMap.put(\"2\", \"b\");\\nhashMap.put(\"1\", \"a\");\\nIterator'),n(\"String\",[a._v(' iteratorHashMap = hashMap.keySet().iterator();\\nSystem.out.println(\"HashMap--\\x3e\");\\nwhile (iteratorHashMap.hasNext()){\\nObject key1 = iteratorHashMap.next();\\nSystem.out.println(key1 + \"--\" + hashMap.get(key1));\\n}\\n//LinkedHashMap\\nLinkedHashMap<String,String> linkedHashMap = new LinkedHashMap();\\nlinkedHashMap.put(\"4\", \"d\");\\nlinkedHashMap.put(\"3\", \"c\");\\nlinkedHashMap.put(\"2\", \"b\");\\nlinkedHashMap.put(\"1\", \"a\");\\nIterator'),n(\"String\",[a._v(' iteratorLinkedHashMap = linkedHashMap.keySet().iterator();\\nSystem.out.println(\"LinkedHashMap--\\x3e\");\\nwhile (iteratorLinkedHashMap.hasNext()){\\nObject key2 = iteratorLinkedHashMap.next();\\nSystem.out.println(key2 + \"--\" + linkedHashMap.get(key2));\\n}\\n//TreeMap\\nTreeMap<String,String> treeMap = new TreeMap();\\ntreeMap.put(\"4\", \"d\");\\ntreeMap.put(\"3\", \"c\");\\ntreeMap.put(\"2\", \"b\");\\ntreeMap.put(\"1\", \"a\");\\nIterator'),n(\"String\",[a._v(' iteratorTreeMap = treeMap.keySet().iterator();\\nSystem.out.println(\"TreeMap--\\x3e\");\\nwhile (iteratorTreeMap.hasNext()){\\nObject key3 = iteratorTreeMap.next();\\nSystem.out.println(key3 + \"--\" + treeMap.get(key3));\\n}\\n}\\n}\\n输出结果：\\nHashMap--\\x3e\\n3--c\\n2--b\\n1--a\\n4--d\\nLinkedHashMap--\\x3e\\n4--d\\n3--c\\n2--b\\n1--a\\nTreeMap--\\x3e\\n1--a\\n2--b\\n3--c\\n4--d\\n4.HashSet、LinkedHashSet、TreeSet 比较\\nSet 接口\\nSet 不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add 方法返回 false。\\n**Set 判断两个对象相同不是使用 == 运算符，而是根据 equals 方法。'),n(\"strong\",[a._v(\"也就是说，只要两个对象用 equals 方法比较返回 true，Set 就不会接受这两个对象。\\nHashSet\\nHashSet 有以下特点：\\n• 不能保证元素的排列顺序，顺序有可能发生变化。\\n• 不是同步的。\\n• 集合元素可以是 null，但只能放入一个 null。\\n当向 HashSet 结合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值来决定该对象在 HashSet 中存储位置。简单的说，HashSet 集合判断两个元素相等的标准是两个对象通过 equals 方法比较相等，并且两个对象的 hashCode() 方法返回值也相等。\\n注意，如果要把一个对象放入 HashSet 中，重写该对象对应类的 equals 方法，也应该重写其 hashCode() 方法。其规则是如果两个对象通过 equals 方法比较返回 true 时，其 hashCode 也应该相同。另外，对象中用作 equals 比较标准的属性，都应该用来计算 hashCode 的值。\\nLinkedHashSet\\nLinkedHashSet 集合同样是根据元素的 hashCode 值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet 将会以元素的添加顺序访问集合的元素。\\nLinkedHashSet 在迭代访问 Set 中的全部元素时，性能比 HashSet 好，但是插入时性能稍微逊色于 HashSet。\\nTreeSet 类\\nTreeSet 是 SortedSet 接口的唯一实现类，TreeSet 可以确保集合元素处于排序状态。TreeSet 支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向 TreeSet 中加入的应该是同一个类的对象。\\nTreeSet 判断两个对象不相等的方式是两个对象通过 equals 方法返回 false，或者通过 CompareTo 方法比较没有返回 0。\\n自然排序\\n自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。\\nJava 提供了一个 Comparable 接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。obj1.compareTo(obj2)方法如果返回 0，则说明被比较的两个对象相等，如果返回一个正数，则表明 obj1 大于 obj2，如果是负数，则表明 obj1 小于 obj2。如果我们将两个对象的 equals 方法总是返回 true，则这两个对象的 compareTo 方法返回应该返回 0。\\n定制排序\\n自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用 Comparator 接口，实现 int compare(T o1,T o2)方法。\\npackage com.test;\"),n(\"br\"),a._v(\"\\nimport java.util.HashSet;\"),n(\"br\"),a._v(\"\\nimport java.util.LinkedHashSet;\"),n(\"br\"),a._v(\"\\nimport java.util.TreeSet;\"),n(\"br\"),a._v(\"\\n/\")])])],1)],1)],1),a._v(\" \"),n(\"ul\",[n(\"li\",[a._v(\"@description 几个set的比较\")]),a._v(\" \"),n(\"li\",[a._v(\"HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放；\")]),a._v(\" \"),n(\"li\",[a._v(\"LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代；\")]),a._v(\" \"),n(\"li\",[a._v(\"TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。\")]),a._v(\" \"),n(\"li\",[a._v(\"@author Zhou-Jingxian\")]),a._v(\" \"),n(\"li\")]),a._v(\" \"),n(\"p\",[a._v(\"*/\"),n(\"br\"),a._v(\"\\npublic class SetDemo {\"),n(\"br\"),a._v(\"\\npublic static void main(String[] args) {\"),n(\"br\"),a._v(\"\\nHashSet\"),n(\"String\",[a._v(\" hs = new HashSet\"),n(\"String\",[a._v(\"();\"),n(\"br\"),a._v('\\nhs.add(\"B\");'),n(\"br\"),a._v('\\nhs.add(\"A\");'),n(\"br\"),a._v('\\nhs.add(\"D\");'),n(\"br\"),a._v('\\nhs.add(\"E\");'),n(\"br\"),a._v('\\nhs.add(\"C\");'),n(\"br\"),a._v('\\nhs.add(\"F\");'),n(\"br\"),a._v('\\nSystem.out.println(\"HashSet 顺序:\\\\n\"+hs);'),n(\"br\"),a._v(\"\\nLinkedHashSet\"),n(\"String\",[a._v(\" lhs = new LinkedHashSet\"),n(\"String\",[a._v(\"();\"),n(\"br\"),a._v('\\nlhs.add(\"B\");'),n(\"br\"),a._v('\\nlhs.add(\"A\");'),n(\"br\"),a._v('\\nlhs.add(\"D\");'),n(\"br\"),a._v('\\nlhs.add(\"E\");'),n(\"br\"),a._v('\\nlhs.add(\"C\");'),n(\"br\"),a._v('\\nlhs.add(\"F\");'),n(\"br\"),a._v('\\nSystem.out.println(\"LinkedHashSet 顺序:\\\\n\"+lhs);'),n(\"br\"),a._v(\"\\nTreeSet\"),n(\"String\",[a._v(\" ts = new TreeSet\"),n(\"String\",[a._v(\"();\"),n(\"br\"),a._v('\\nts.add(\"B\");'),n(\"br\"),a._v('\\nts.add(\"A\");'),n(\"br\"),a._v('\\nts.add(\"D\");'),n(\"br\"),a._v('\\nts.add(\"E\");'),n(\"br\"),a._v('\\nts.add(\"C\");'),n(\"br\"),a._v('\\nts.add(\"F\");'),n(\"br\"),a._v('\\nSystem.out.println(\"TreeSet 顺序:\\\\n\"+ts);'),n(\"br\"),a._v(\"\\n}\"),n(\"br\"),a._v(\"\\n}\\n输出结果：\\nHashSet 顺序:[D, E, F, A, B, C]\\nLinkedHashSet 顺序:[B, A, D, E, C, F]\\nTreeSet 顺序:[A, B, C, D, E, F]\\n5、Iterator 和 ListIterator 区别\\n我们在使用 List，Set 的时候，为了实现对其数据的遍历，我们经常使用到了 Iterator(迭代器)。使用迭代器，你不需要干涉其遍历的过程，只需要每次取出一个你想要的数据进行处理就可以了。但是在使用的时候也是有不同的。\\nList 和 Set 都有iterator()来取得其迭代器。对 List 来说，你也可以通过 listIterator() 取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator 和 ListIterator 主要区别在以下方面：\\n• ListIterator 有add()方法，可以向 List 中添加对象，而 Iterator 不能\\n• ListIterator 和 Iterator 都有hasNext()和next()方法，可以实现顺序向后遍历，但是 ListIterator 有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator 就不可以。\\n• ListIterator 可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator 没有此功能。\\n• 都可实现删除对象，但是 ListIterator 可以实现对象的修改，set()方法可以实现。Iierator 仅能遍历，不能修改。\\n因为 ListIterator 的这些功能，可以实现对 LinkedList 等 List 数据结构的操作。其实，数组对象也可以用迭代器来实现。\\n6、Collection 和 Collections 区别\\n**（1）java.util.Collection 是一个集合接口（集合类的一个顶级接口）。**它提供了对集合对象进行基本操作的通用接口方法。Collection 接口在 Java 类库中有很多具体的实现。Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有 List 与 Set。\\nCollection\"),n(\"br\"),a._v(\"\\n├List\"),n(\"br\"),a._v(\"\\n│├LinkedList\"),n(\"br\"),a._v(\"\\n│├ArrayList\"),n(\"br\"),a._v(\"\\n│└Vector\"),n(\"br\"),a._v(\"\\n│　└Stack\"),n(\"br\"),a._v(\"\\n└Set\\n（2）java.util.Collections 是一个包装类（工具类 / 帮助类）。**它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于 Java 的 Collection 框架。\\n代码示例：\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.List;\\npublic class TestCollections {\\npublic static void main(String args[]) {\\n//注意List是实现Collection接口的\\nList list = new ArrayList();\\ndouble array[] = { 112, 111, 23, 456, 231 };\\nfor (int i = 0; i < array.length; i++) {\\nlist.add(new Double(array[i]));\\n}\\nCollections.sort(list);\\nfor (int i = 0; i < array.length; i++) {\\nSystem.out.println(list.get(i));\\n}\\n// 结果：23.0 111.0 112.0 231.0 456.0\\n}\\n}\\n并发修改异常\\n出现的原因\\n迭代器遍历的过程中,通过集合对象修改集合中的元素,造成了迭代器获取元素中判断\\n预期修改值和实际修改值不一致,则会出现:ConcurrentModificationException\\n解决方案\\n用for循环遍历,然后用集合对象序做对应的操作即可\\n如果要在foreach循环中删除list中的元素，要使用itrator迭代器，借助itrator的remove方法删除元素，若使用list的remove方法则会抛出异常\")])],1)],1)],1)],1)],1)],1)])}),[],!1,null,null,null);e.default=r.exports}}]);","extractedComments":[]}