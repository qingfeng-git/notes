{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{366:function(s,a,t){\"use strict\";t.r(a);var n=t(44),v=Object(n.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"一-计算机大概描述\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一-计算机大概描述\"}},[s._v(\"#\")]),s._v(\" 一.计算机大概描述\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"_1-数据存放的位置\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-数据存放的位置\"}},[s._v(\"#\")]),s._v(\" 1.数据存放的位置:\")]),s._v(\" \"),t(\"p\",[s._v(\"移动硬盘,U盘 内存(如遇到断电,内存上面存储的数据将会丢失). .. .\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"内存:\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"1️⃣\")]),s._v(\"内存由一个有序的字节序列组成,用于存储程序及程序需要的数据\")]),s._v(\" \"),t(\"p\",[s._v(\"2️⃣一个程序和它的数据在被CPU执行前必须移到计算机的内存中\")]),s._v(\" \"),t(\"p\",[s._v(\"3️⃣内存是带电存储的(一旦断电数据就是会消失),而且容量有限,所以要长时间存储程序或者数据就需要使用硬盘\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1607511625221-05c80167-4f3e-4e96-8185-c486453d096f.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"比特(bit)和字节(byte)的区别:\")])]),s._v(\" \"),t(\"p\",[s._v(\"1️⃣计算机就是一系列的电路开关,每个开关都会存在两种状态,关(off)或开(on),如果电路是开的,那么他就是1,否则就是0.\")]),s._v(\" \"),t(\"p\",[s._v(\"2️⃣一个0或者一个1存储为一个比特(bit),是计算机最小的存储单位\")]),s._v(\" \"),t(\"p\",[s._v(\"3️⃣计算机中最基本的存储单元是字节(byte).每个字节由8个比特构成\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"_2-操作系统\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-操作系统\"}},[s._v(\"#\")]),s._v(\" 2.操作系统\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"操作系统是运行在计算机上面的最重要的程序,它可以管理和控制计算机的活动\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"操作系统的主要任务:\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[s._v(\"控制和监视系统活动\")])]),s._v(\" \"),t(\"li\",[t(\"strong\",[s._v(\"分配和调配系统资源\")])]),s._v(\" \"),t(\"li\",[t(\"strong\",[s._v(\"调度操作\")])])]),s._v(\" \"),t(\"p\",[s._v(\"硬件,操作系统,应用程序和用户之间的关系如下图:\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1607512326799-2b78f54f-4866-446c-8c8d-86d18b48912c.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"h2\",{attrs:{id:\"_3-万维网\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-万维网\"}},[s._v(\"#\")]),s._v(\" 3.万维网\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"万维网是无数个网络站点和网页的集合,它们在一起构成了因特网(互联网包含了因特网,因特网又包含了万维网)\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"万维网分为\"),t(\"strong\",[t(\"strong\",[s._v(\"WEB客户端和WEB服务器端\")])]),s._v(\",www可以让WEB客户端(常用浏览器)\"),t(\"strong\",[t(\"strong\",[s._v(\"访问WEB服务器端上的页面\")])]),s._v('.是一个由许多互相链接的超文本组成的系统,通过互联网访问,在这个系统中,每一个有用的事物,称为一样\"资源\",并且由一个全局')]),s._v('**\"统一的资源标识符\"(URI)标'),t(\"strong\",[t(\"strong\",[s._v(\"识;这些资源通过\")])]),s._v(\"超文本传输协议****传送给用户,而后者通过点击链接来获得资源**\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1607513228064-9ffee0c0-f826-4a1c-97f3-212fec8aa2d2.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"p\",[s._v(\"www就是万维网,www.baidu.com就是统一的资源标识符\")]),s._v(\" \"),t(\"p\",[s._v(\"http就是超文本传输协议\")]),s._v(\" \"),t(\"p\",[s._v(\"B/S 架构:browser/server  浏览器/服务器 (浏览器也是一个特殊的客户端)\")]),s._v(\" \"),t(\"p\",[s._v(\"C/S 架构:client/server     QQ,微信(应用程序)/服务器\")]),s._v(\" \"),t(\"h1\",{attrs:{id:\"二-java语言基础\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二-java语言基础\"}},[s._v(\"#\")]),s._v(\" 二.JAVA语言基础\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1607521381204-a0ceb9ff-7d60-4558-94a9-3e46ee40bbfd.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"java运行的大概流程是我们编写的java程序都会被虚拟机翻译成.class文件,运行在JVM中,JVM又处于操作系统上,最终和硬件交互!\")])]),s._v(\" \"),t(\"h2\",{attrs:{id:\"什么是jdk-jre\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是jdk-jre\"}},[s._v(\"#\")]),s._v(\" 什么是JDK,JRE?\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"JDK(JAVA开发工具包)\")]),s._v(\":是提供给JAVA开发人员使用的,其中包含了JAVA的开发工具,也包括了JRE,所以安装了JDK,就不用单独安装JRE了,其中开发工具:编译工具(javac.exe) 打包工具(jar.exe)等\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"JRE(JAVA运行环境)\")]),s._v(\":包括JAVA虚拟机和JAVA程序所需的核心类库等,如果想要运行一个开发好的JAVA程序,计算机中只需要安装JRE即可\")]),s._v(\" \"),t(\"p\",[s._v(\"简单而言,使用JDK的开发工具完成的JAVA程序,交给JRE去运行,关系如下图所示:\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1607521848603-f184464c-885b-4617-914f-933ce75ff527.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"p\",[s._v(\"一个JAVA文件的编译过程:\")]),s._v(\" \"),t(\"ol\",[t(\"li\",[s._v(\"将JAVA代码编写到扩展名为.java的文件中\")]),s._v(\" \"),t(\"li\",[s._v(\"通过javac 命令对该文件进行编译  命令:javac 类名带后缀\")]),s._v(\" \"),t(\"li\",[s._v(\"通过java命令对生成的class文件进行运行 java 类名不带后缀\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"在一个java源文件中可以声明多个class,但是,只能最多有一个类声明为public的,而且要求声明为public的类名必须与源文件名相同\")])]),s._v(\" \"),t(\"h2\",{attrs:{id:\"注释\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#注释\"}},[s._v(\"#\")]),s._v(\" 注释\")]),s._v(\" \"),t(\"p\",[s._v(\"单行注释:注释内容不参与Java文件的编译\")]),s._v(\" \"),t(\"p\",[s._v(\"多行注释:注释内容不参与Java文件的编译\")]),s._v(\" \"),t(\"p\",[s._v(\"文档注释:注释内容可以被JDK提供的工具javadoc所解析,生成一套以网页文件形式体现的该程序的说明文档,操作方式命令行输入  :jav  adoc -d mydoc -auther -version HelloWorld.java\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"关键字\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#关键字\"}},[s._v(\"#\")]),s._v(\" 关键字\")]),s._v(\" \"),t(\"p\",[s._v(\"定义:被Java语言赋予了特殊含义,用于专门用途的字符串\")]),s._v(\" \"),t(\"p\",[s._v(\"特点:关键字中所有的字母都为小写\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1607523174043-a2b109db-f259-4d90-a71d-1f34a2045e97.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"h2\",{attrs:{id:\"变量\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#变量\"}},[s._v(\"#\")]),s._v(\" 变量\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"变量的概念:\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"内存中的一个存储区域\")]),s._v(\" \"),t(\"li\",[s._v(\"该区域的数据可以在同一类型范围内不断变化\")]),s._v(\" \"),t(\"li\",[s._v(\"变量是程序中最基本的存储单元,包含变量类型,变量名和存储的值\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"变量的作用:\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"用于在内存中保存数据\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"使用变量注意:\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"Java中每个变量必须先声明,后使用\")]),s._v(\" \"),t(\"li\",[s._v(\"使用变量名来访问这块区域的数据\")]),s._v(\" \"),t(\"li\",[s._v(\"变量的作用域:其定义所在的一对{}内\")]),s._v(\" \"),t(\"li\",[s._v(\"变量只有在其作用域内才有效\")]),s._v(\" \"),t(\"li\",[s._v(\"同一个作用域内,不能定义重名的变量\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"按数据类型分类:\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"1.基本数据类型（4型8种）:\")])]),s._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\",[t(\"strong\",[s._v(\"序号\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"分类\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"数据类型\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"占用字节数\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"默认值\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"取值范围\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"备注\")])])])]),s._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[s._v(\"1\")]),s._v(\" \"),t(\"td\",[s._v(\"整型\")]),s._v(\" \"),t(\"td\",[s._v(\"byte(位)\")]),s._v(\" \"),t(\"td\",[s._v(\"1\")]),s._v(\" \"),t(\"td\",[s._v(\"0\")]),s._v(\" \"),t(\"td\",[s._v(\"-2^7 - 2^7-1\")]),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"2\")]),s._v(\" \"),t(\"td\",[s._v(\"short(短整数)\")]),s._v(\" \"),t(\"td\",[s._v(\"2\")]),s._v(\" \"),t(\"td\",[s._v(\"0\")]),s._v(\" \"),t(\"td\",[s._v(\"-2^15 - 2^15-1\")]),s._v(\" \"),t(\"td\"),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"3\")]),s._v(\" \"),t(\"td\",[s._v(\"int(整数)\")]),s._v(\" \"),t(\"td\",[s._v(\"4\")]),s._v(\" \"),t(\"td\",[s._v(\"0\")]),s._v(\" \"),t(\"td\",[s._v(\"-2^31 - 2^31-1\")]),s._v(\" \"),t(\"td\"),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"4\")]),s._v(\" \"),t(\"td\",[s._v(\"long(长整数)\")]),s._v(\" \"),t(\"td\",[s._v(\"8\")]),s._v(\" \"),t(\"td\",[s._v(\"0\")]),s._v(\" \"),t(\"td\",[s._v(\"-2^63 - 2^63-1\")]),s._v(\" \"),t(\"td\",[s._v(\"后缀需要加L，0L，尾数可以精确到7位有效数字\")]),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"5\")]),s._v(\" \"),t(\"td\",[s._v(\"浮点型\")]),s._v(\" \"),t(\"td\",[s._v(\"float(单精度)\")]),s._v(\" \"),t(\"td\",[s._v(\"4\")]),s._v(\" \"),t(\"td\",[s._v(\"0.0\")]),s._v(\" \"),t(\"td\",[s._v(\"-2^31 - 2^31-1\")]),s._v(\" \"),t(\"td\",[s._v(\"后缀需要加F，0.0F\")])]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"6\")]),s._v(\" \"),t(\"td\",[s._v(\"double(双精度)\")]),s._v(\" \"),t(\"td\",[s._v(\"8\")]),s._v(\" \"),t(\"td\",[s._v(\"0.0\")]),s._v(\" \"),t(\"td\",[s._v(\"-2^63 - 2^63-1\")]),s._v(\" \"),t(\"td\",[s._v(\"尾数可以精确到float尾数的2倍\")]),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"7\")]),s._v(\" \"),t(\"td\",[s._v(\"字符型\")]),s._v(\" \"),t(\"td\",[s._v(\"char(字符)\")]),s._v(\" \"),t(\"td\",[s._v(\"2\")]),s._v(\" \"),t(\"td\",[s._v(\"\\\\ u0000\")]),s._v(\" \"),t(\"td\",[s._v(\"0 - 2^16-1\")]),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"8\")]),s._v(\" \"),t(\"td\",[s._v(\"布尔型\")]),s._v(\" \"),t(\"td\",[s._v(\"boolean(布尔值)\")]),s._v(\" \"),t(\"td\",[s._v(\"1\")]),s._v(\" \"),t(\"td\",[s._v(\"false\")]),s._v(\" \"),t(\"td\",[s._v(\"true、false\")]),s._v(\" \"),t(\"td\")])])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"2.引用数据类型:\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"ul\",[t(\"li\",[s._v(\"类(class)--String类在这\")]),s._v(\" \"),t(\"li\",[s._v(\"接口(interface)\")]),s._v(\" \"),t(\"li\",[s._v(\"数组(array)\")]),s._v(\" \"),t(\"li\")])])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"注意点：\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[s._v(\"1字节=8bit,一个bit要么是1,要么就是0,所以一个bit有2种情况,所以1个byte的表示范围就是2的8次方,short,int,long依次类推计算表示范围\")])]),s._v(\" \"),t(\"li\",[t(\"strong\",[s._v(\"由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标\")])]),s._v(\" \"),t(\"li\",[s._v(\"定义char类型变量,通常使用一对' ',内部只能写一个字符,不可以'AB',也可以写中文,比如'中';\")]),s._v(\" \"),t(\"li\",[s._v(\"直接使用Unicode值来表示字符型常量,char  a = '\\\\u0043' 输出的是大写字母C;\")]),s._v(\" \"),t(\"li\",[s._v(\"char类型是可以进行运算的,因为它都对应有Unicode码表**\\n**\")]),s._v(\" \"),t(\"li\",[s._v(\"对于每一种数据类型都定义了明确的具体数据类型(强类型语言),在内存中分配了不同大小的内存空间\")])]),s._v(\" \"),t(\"p\",[t(\"a\",{attrs:{href:\"https://blog.csdn.net/qq_23418393/article/details/57421688\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"Java中，为什么byte类型的取值范围为-128~127?\"),t(\"OutboundLink\")],1)]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"按声明位置不同:\")])]),s._v(\" \"),t(\"p\",[s._v(\"Java中共有三种变量，分别是类变量、成员变量和局部变量。他们分别存放在JVM的方法区、堆内存和栈内存中\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"public class Variables  {\\n\\n    /**\\n     * 类变量\\n     */\\n    private static int a;\\n\\n    /**\\n     * 成员变量\\n     */\\n    private int b;\\n\\n    /**\\n     * 局部变量\\n     */\\n    public void test(int c){\\n        int d;\\n    }\\n}\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),t(\"br\")])]),t(\"p\",[s._v(\"上面定义的三个变量中，变量a就是类变量，变量b就是成员变量，而变量c和d是局部变量。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"字符型:ASCII码表:\")])]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1608194981352-b79e8eb7-754e-46aa-843c-34d0d7f85651.png\",alt:\"码表.png\"}})]),s._v(\" \"),t(\"h2\",{attrs:{id:\"基本数据类型的运算规则-自动转换\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#基本数据类型的运算规则-自动转换\"}},[s._v(\"#\")]),s._v(\" 基本数据类型的运算规则(自动转换)\")]),s._v(\" \"),t(\"p\",[s._v(\"前提是boolean类型不参与任何的数据类型转换\")]),s._v(\" \"),t(\"p\",[s._v(\"1.自动类型转换提升:\")]),s._v(\" \"),t(\"p\",[s._v(\"结论:当容量小的数据类型的变量与容量大的数据类型的变量做运算时,结果自动提升为容量大的数据类型\")]),s._v(\" \"),t(\"p\",[s._v(\"byte , char ,short ,int -> long -> float -> double\")]),s._v(\" \"),t(\"p\",[s._v(\"特别的:当byte,char,short这三种类型做运算的时候,结果转为int类型\")]),s._v(\" \"),t(\"p\",[s._v(\"2.强制类型转换:自动类型提升的逆运算\")]),s._v(\" \"),t(\"p\",[s._v(\"需要使用强转符号:()\")]),s._v(\" \"),t(\"p\",[s._v(\"注意点:强制类型转换,可能导致精度损失\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"进制与进制之间的转换\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进制与进制之间的转换\"}},[s._v(\"#\")]),s._v(\" 进制与进制之间的转换\")]),s._v(\" \"),t(\"p\",[s._v(\"所有数字在计算机底层都以二进制形式存在\")]),s._v(\" \"),t(\"p\",[s._v(\"对于整数,有四种表示方式:\")]),s._v(\" \"),t(\"p\",[s._v(\"二进制(binary):0,1,满2进1.以0b或0B开头\")]),s._v(\" \"),t(\"p\",[s._v(\"十进制(decimal):0-9,满10进1\")]),s._v(\" \"),t(\"p\",[s._v(\"八进制(octal):0-7 ,满8进1,以数字0开头表示\")]),s._v(\" \"),t(\"p\",[s._v(\"十六进制(hex):0-9及A-F,满16进1,以0x或者0X开头表示,此处的A-F不区分大小写,如0x21AF+1=0X21B0\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1607527854039-7711716d-e6dc-42ee-a780-615a49cb824c.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1607527867866-bddb8ac7-fe13-4db8-be58-21f6909f5d8d.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"h2\",{attrs:{id:\"运算符\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#运算符\"}},[s._v(\"#\")]),s._v(\" 运算符\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"算术运算符\")])]),s._v(\" \"),t(\"p\",[s._v(\"++(前):先增1,后运算\")]),s._v(\" \"),t(\"p\",[s._v(\"(后)++:先运算,后自增1\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1607609675293-96493e04-9cba-455b-a8a2-ae2b75c441d2.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"赋值运算符\")])]),s._v(\" \"),t(\"p\",[s._v(\"=\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"比较运算符\")]),s._v(\" \"),t(\"li\",[s._v(\"逻辑运算符\")])]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1607610157245-8fdaa468-8a72-4b78-a7a0-eea4d6bcaf5b.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"位运算符\")])]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1607610224087-bbeed5fb-4b53-40d0-9f5c-3f8f0dc02cda.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"三元运算符\")])]),s._v(\" \"),t(\"h2\",{attrs:{id:\"流程控制语句\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#流程控制语句\"}},[s._v(\"#\")]),s._v(\" 流程控制语句\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"循环语句分类\")]),s._v(\" \"),t(\"li\",[s._v(\"for循环\")]),s._v(\" \"),t(\"li\",[s._v(\"while循环\")]),s._v(\" \"),t(\"li\",[s._v(\"do-while循环\")]),s._v(\" \"),t(\"li\",[s._v(\"switch-判断语句，实际上CPU根据指令去进行跳转的，但是他不同于if这种有跳转指令。如果分支较少，可能会采用跳转指令，如果分支较多，会采用跳转表，跳转表是一个映射表，存储了可能的值以及要跳转到的地址\")])]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2021/png/1158395/1610682568792-ed745f63-6fe0-4623-b9e1-2f0d84c75bcc.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"break:结束当前循环 (如果加入标签的话,break可以跳出指定的循环体,默认是跳出包裹此关键字的最近的一层循环)\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"continue:结束当次循环\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"return:它的功能是结束一个方法,不管这个return处于多少层循环之内,都会直接跳出整个方法\")])]),s._v(\" \"),t(\"h1\",{attrs:{id:\"三-数组\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三-数组\"}},[s._v(\"#\")]),s._v(\" 三.数组\")]),s._v(\" \"),t(\"p\",[s._v(\"是多个相同类型的数据按一定顺序排列的集合,并用一个名字命名,并通过编号的方式对这些数据进行统一管理\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"数组常见的概念\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数组常见的概念\"}},[s._v(\"#\")]),s._v(\" 数组常见的概念\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"特点\")])]),s._v(\" \"),t(\"ol\",[t(\"li\",[s._v(\"数组本身是引用数据类型,而数组中的元素可以是任何数据类型,包括基本数据类型和引用数据类型\")]),s._v(\" \"),t(\"li\",[s._v(\"创建数组对象会在内存中开辟一整块连续的空间,而数组名中引用的是这块连续空间的地址\")]),s._v(\" \"),t(\"li\",[s._v(\"数组的长度一旦确定,就不能修改\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"数组名\")]),s._v(\" \"),t(\"li\",[s._v(\"下标(索引)\")]),s._v(\" \"),t(\"li\",[s._v(\"元素\")]),s._v(\" \"),t(\"li\",[s._v(\"数组的长度\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"数组初始化\")])]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"int [] ids;//声明\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\")])]),t(\"p\",[s._v(\"1.1-静态初始化:数组的初始化和数组元素的赋值操作同时进行\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"ids = new int[]{1001,1002,1003,1004};\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\")])]),t(\"p\",[s._v(\"1.2-动态初始化:数组的初始化和数组元素的赋值操作分开进行\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v('        String[] names = new String[5];\\n        names[0] = \"张三\";\\n        names[1] = \"李四\";\\n        names[2] = \"王五\";\\n')])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\")])]),t(\"p\",[s._v(\"总结:数组一旦初始化完成,其长度就已经确定了,不能在进行更改\")]),s._v(\" \"),t(\"p\",[s._v(\"获取数组的长度:通过length属性,并不是方法\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"数组中常见的算法题\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数组中常见的算法题\"}},[s._v(\"#\")]),s._v(\" 数组中常见的算法题\")]),s._v(\" \"),t(\"p\",[s._v(\"数组元素的查找\")]),s._v(\" \"),t(\"p\",[s._v(\"线性查找:相当于循环遍历去匹配,匹配到就返回,普通的循环遍历查找\")]),s._v(\" \"),t(\"p\",[s._v(\"二分查找(折半查找):前提所要查找的数组必须有序\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v('/**\\n *二分查找-代码需要调整\\n */\\npublic class Test01 {\\n    public static void main(String[] args) {\\n        int[] arr = new int[]{1,2,3,4,5,6,7,8};\\n        int dest = 8;//要找的数据\\n        int head  = 0; //初始的首索引\\n        int end = arr.length-1;//初始的末索引\\n        while (head <= end){\\n            int middle = (head+end)/2;//获取中间索引\\n            if (dest == arr[middle]){\\n                System.out.println(\"找到了索引是\"+middle);\\n                break;\\n            }else if (arr[middle] >dest){\\n                end = middle -1;\\n            }else {\\n                end = middle+1;\\n            }\\n        }\\n    }\\n}\\n')])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"20\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"21\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"22\")]),t(\"br\")])]),t(\"h1\",{attrs:{id:\"四-面向对象\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#四-面向对象\"}},[s._v(\"#\")]),s._v(\" 四.面向对象\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"面向过程-pop\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#面向过程-pop\"}},[s._v(\"#\")]),s._v(\" 面向过程(POP)\")]),s._v(\" \"),t(\"h4\",{attrs:{id:\"概述-自顶而下的编程模式\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#概述-自顶而下的编程模式\"}},[s._v(\"#\")]),s._v(\" \"),t(\"a\",{attrs:{href:\"http://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/object-oriented-vs-procedure-oriented?id=%E6%A6%82%E8%BF%B0-%E8%87%AA%E9%A1%B6%E8%80%8C%E4%B8%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"概述: 自顶而下的编程模式.\"),t(\"OutboundLink\")],1)]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。\")]),s._v(\" \"),t(\"li\",[s._v(\"就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。\")]),s._v(\" \"),t(\"li\",[s._v(\"最典型的用法就是实现一个简单的算法，比如实现冒泡排序。\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"面向对象-oop\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#面向对象-oop\"}},[s._v(\"#\")]),s._v(\" 面向对象(OOP)\")]),s._v(\" \"),t(\"h4\",{attrs:{id:\"概述-将事务高度抽象化的编程模式\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#概述-将事务高度抽象化的编程模式\"}},[s._v(\"#\")]),s._v(\" \"),t(\"a\",{attrs:{href:\"http://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/object-oriented-vs-procedure-oriented?id=%E6%A6%82%E8%BF%B0-%E5%B0%86%E4%BA%8B%E5%8A%A1%E9%AB%98%E5%BA%A6%E6%8A%BD%E8%B1%A1%E5%8C%96%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"概述: 将事务高度抽象化的编程模式.\"),t(\"OutboundLink\")],1)]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。\")]),s._v(\" \"),t(\"li\",[s._v(\"就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。\")]),s._v(\" \"),t(\"li\",[s._v(\"比如:想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#区别\"}},[s._v(\"#\")]),s._v(\" 区别\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[s._v(\"二者都是一种思想,面向对象是相对于面向过程而言的.面向过程,强调的是功能的行为,以函数(方法)为最小单位,考虑怎么做.面向对象,将功能封装成对象,强调具备了功能的对象,以类/对象为最小单位,考虑谁来做.\")])]),s._v(\" \"),t(\"li\",[t(\"p\",[s._v(\"面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则,如抽象,分类,继承,聚合,多态等.\")])])]),s._v(\" \"),t(\"h4\",{attrs:{id:\"优劣对比\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#优劣对比\"}},[s._v(\"#\")]),s._v(\" 优劣对比\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"面向对象:占用资源相对高,速度相对慢\")]),s._v(\" \"),t(\"li\",[s._v(\"面向过程:占用资源相对低,速度相对快\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"java类及类的成员\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#java类及类的成员\"}},[s._v(\"#\")]),s._v(\" Java类及类的成员\")]),s._v(\" \"),t(\"h4\",{attrs:{id:\"类-class\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#类-class\"}},[s._v(\"#\")]),s._v(\" 类(class)\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"ul\",[t(\"li\",[s._v(\"类是对一类事物的描述,是抽象的,概念上的定义\")]),s._v(\" \"),t(\"li\",[s._v(\"设计类就是设计类的成员\")])])])]),s._v(\" \"),t(\"h4\",{attrs:{id:\"对象-object\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对象-object\"}},[s._v(\"#\")]),s._v(\" 对象(object)\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"ul\",[t(\"li\",[s._v(\"对象是实际存在的该类事物的每个个体,因而也被称为实例(instance)\")]),s._v(\" \"),t(\"li\",[s._v(\"一个类被实例化了就是创建一个对象,创建类的对象=类的实例化=实例化类\")])])])]),s._v(\" \"),t(\"h4\",{attrs:{id:\"匿名对象\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#匿名对象\"}},[s._v(\"#\")]),s._v(\" 匿名对象\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"ul\",[t(\"li\",[s._v(\"没有显式的赋给一个变量名,即为匿名对象\")]),s._v(\" \"),t(\"li\",[s._v(\"匿名对象只能调用一次\")])])])]),s._v(\" \"),t(\"h4\",{attrs:{id:\"属性\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#属性\"}},[s._v(\"#\")]),s._v(\" 属性\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"ul\",[t(\"li\",[s._v(\"对应类中的成员变量  对象.属性(调用)\")])])])]),s._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\",[t(\"strong\",[s._v(\"属性\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"成员变量(属性)\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"局部变量\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"类变量\")])])])]),s._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[s._v(\"位置\")]),s._v(\" \"),t(\"td\",[s._v(\"方法体外,类体内,非staic修饰\")]),s._v(\" \"),t(\"td\",[s._v(\"方法体内,形参,构造器形参,构造器内部变量\")]),s._v(\" \"),t(\"td\",[s._v(\"staic修饰\")])]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"初始化值\")]),s._v(\" \"),t(\"td\",[s._v(\"有,根据其类型有相应的默认值\")]),s._v(\" \"),t(\"td\",[s._v(\"无,需要赋值才能够使用\")]),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"作用域\")]),s._v(\" \"),t(\"td\",[s._v(\"类中\")]),s._v(\" \"),t(\"td\",[s._v(\"方法体中\")]),s._v(\" \"),t(\"td\",[s._v(\"类中\")])]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"内存中的位置\")]),s._v(\" \"),t(\"td\",[s._v(\"堆空间\")]),s._v(\" \"),t(\"td\",[s._v(\"栈空间\")]),s._v(\" \"),t(\"td\",[s._v(\"方法区\")])])])]),s._v(\" \"),t(\"h4\",{attrs:{id:\"方法-函数\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#方法-函数\"}},[s._v(\"#\")]),s._v(\" 方法(函数)\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"ul\",[t(\"li\",[s._v(\"对应类中的成员方法 对象.方法(调用)\")])])])]),s._v(\" \"),t(\"p\",[s._v(\"return:\")]),s._v(\" \"),t(\"p\",[s._v(\"使用范围:使用在方法体中.\")]),s._v(\" \"),t(\"p\",[s._v(\"作用:结束方法,返回数据.\")]),s._v(\" \"),t(\"p\",[s._v(\"return后面不可以声明执行语句.\")]),s._v(\" \"),t(\"h4\",{attrs:{id:\"方法的重载\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#方法的重载\"}},[s._v(\"#\")]),s._v(\" 方法的重载\")]),s._v(\" \"),t(\"p\",[s._v(\"在同一个类中,允许存在一个以上的同名方法,只要它们的参数个数或者参数类型不同即可\")]),s._v(\" \"),t(\"p\",[s._v(\"特点:\")]),s._v(\" \"),t(\"p\",[s._v(\"与返回值类型无关\")]),s._v(\" \"),t(\"p\",[s._v(\"只看参数列表\")]),s._v(\" \"),t(\"p\",[s._v(\"参数列表必须不同(参数个数或类型不同)\")]),s._v(\" \"),t(\"p\",[s._v(\"跟权限修饰无关\")]),s._v(\" \"),t(\"h4\",{attrs:{id:\"可变个数的形参\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#可变个数的形参\"}},[s._v(\"#\")]),s._v(\" 可变个数的形参\")]),s._v(\" \"),t(\"p\",[s._v(\"允许直接定义能和多个实参相匹配的形参,从而可以用一种简单的方法来传递个数可变实参\")]),s._v(\" \"),t(\"p\",[s._v(\"JDK5.0以前:采用数组形参来定义方法,传入多个同一类型变量\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"public  void test(int a,String[] books){};\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\")])]),t(\"p\",[s._v(\"JDK5.0:采用可变个数形参来定义方法,传入多个同一类型变量(该方法需要定义到最后,最多只能声明一个)\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"public static void test01(int a,String...books){\\n        for (int i = 0; i < books.length; i++) {\\n            //可以通过遍历来获取每一个参数的值\\n        }\\n    };\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\")])]),t(\"h4\",{attrs:{id:\"构造器-构造方法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#构造器-构造方法\"}},[s._v(\"#\")]),s._v(\" 构造器(构造方法)\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[s._v(\"作用\")])]),s._v(\" \"),t(\"li\",[t(\"ul\",[t(\"li\",[s._v(\"空参就是来创建对象---User user = new User(); 其实就是new + 构造器( User() )\")]),s._v(\" \"),t(\"li\",[s._v(\"带参初始化对象信息\")])])]),s._v(\" \"),t(\"li\",[t(\"p\",[s._v(\"如果没有显式定义构造器,系统会默认提供一个空参构造器\")])]),s._v(\" \"),t(\"li\",[t(\"p\",[s._v(\"一旦显式定义类的构造器,系统则不会给提供默认空参构造器\")])]),s._v(\" \"),t(\"li\",[t(\"p\",[s._v(\"一个类中至少会有一个构造器\")])])]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"public class User {\\n\\n    private String name;\\n\\n    /**\\n     * 空参构造器(系统会默认生成) 权限和类的权限相同\\n     */\\n    public User() {\\n    }\\n\\n    /**\\n     * 带参构造器(初始化属性值)--构造器重载\\n     * @param name\\n     */\\n    public User(String name) {\\n        this.name = name;\\n    }\\n}\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),t(\"br\")])]),t(\"h4\",{attrs:{id:\"属性赋值先后顺序\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#属性赋值先后顺序\"}},[s._v(\"#\")]),s._v(\" 属性赋值先后顺序\")]),s._v(\" \"),t(\"ol\",[t(\"li\",[s._v(\"默认初始化值\")]),s._v(\" \"),t(\"li\",[s._v(\"显式初始化\")]),s._v(\" \"),t(\"li\",[s._v(\"构造器初始化\")]),s._v(\" \"),t(\"li\",[s._v(\"通过对象.set方法\")])]),s._v(\" \"),t(\"p\",[s._v(\"以上操作赋值先后顺序: 1 - 2 - 3 - 4\")]),s._v(\" \"),t(\"h4\",{attrs:{id:\"关键字-2\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#关键字-2\"}},[s._v(\"#\")]),s._v(\" 关键字\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"this:可以理解为当前对象或当前正在创建的对象!!!\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"它在方法内部使用,即这个方法所属对象的引用\")]),s._v(\" \"),t(\"li\",[s._v(\"它在构造器内部使用,表示该构造器正在初始化的对象\")]),s._v(\" \"),t(\"li\",[s._v(\"this表示当前对象,可以调用类的属性,方法和构造器\")]),s._v(\" \"),t(\"li\",[s._v(\"可以通过this来区分局部变量和属性(this.变量,表名此变量是类属性)\")]),s._v(\" \"),t(\"li\",[s._v(\"调用构造器,可以显示的使用this(形参列表)的方式,调用本类中指定的其他构造器,不能自己调用自己\")]),s._v(\" \"),t(\"li\",[s._v(\"调用构造器,this()这种形式,必须放在构造方法的首行.构造器内部最多只能声明一个this(形参列表)这种方式\")])]),s._v(\" \"),t(\"h4\",{attrs:{id:\"javabean\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#javabean\"}},[s._v(\"#\")]),s._v(\" JavaBean\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"JavaBean是一种Java语言写成的可重用组件\")]),s._v(\" \"),t(\"li\",[s._v(\"所谓JavaBean,是指符合如下标准的Java类\")])]),s._v(\" \"),t(\"ol\",[t(\"li\",[t(\"ol\",[t(\"li\",[s._v(\"类是公共的\")]),s._v(\" \"),t(\"li\",[s._v(\"有一个无参的公共的构造器\")]),s._v(\" \"),t(\"li\",[s._v(\"有属性,且有对应的get,set方法\")])])])]),s._v(\" \"),t(\"h1\",{attrs:{id:\"五-面向对象特征\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#五-面向对象特征\"}},[s._v(\"#\")]),s._v(\" 五.面向对象特征\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"封装\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#封装\"}},[s._v(\"#\")]),s._v(\" 封装\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"p\",[s._v('我们程序设计追求\"高内聚,低耦合\"')])]),s._v(\" \"),t(\"li\",[t(\"ul\",[t(\"li\",[s._v(\"高内聚:类的内部数据操作细节自己完成,不允许外部干涉\")]),s._v(\" \"),t(\"li\",[s._v(\"低耦合:仅对外暴露少量的方法用于使用\")])])]),s._v(\" \"),t(\"li\",[t(\"p\",[s._v(\"隐藏对象内部的复杂性,只对外公开简单的接口,便于外界调用,从而提高系统的可扩展性,可维护性.通俗的说,把该隐藏的隐藏起来,该暴露的暴露出来,这就是封装性的设计思想.\")])])]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"//这个是封装行的一个体现\\n//拓展:1,如下 2,不对外暴露的私有方法,仅限该类内部使用 3,单例模式......\\npublic class User {\\n     /**\\n     * private 体现了隐藏性,不允许外界直接去(对象.属性)访问该属性\\n     * 导致一些类型超出范围的\\n     */\\n    private String name;\\n    \\n    //提供属性获取的方法,可以获取该属性的值\\n    public String getName() {\\n        return name;\\n    }\\n\\n    /**\\n     * setName 体现出来了封装性,虽然不允许外界直接调用属性去赋值\\n     * 但是可以通过封装的方法去给属性赋值,强制使用该方法去赋值,可以对属性进行限制行的校验\\n     */\\n    public void setName(String name) {\\n        this.name = name;\\n    }\\n}\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"20\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"21\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"22\")]),t(\"br\")])]),t(\"p\",[s._v(\"权限修饰符--从上往下范围依次递增\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"置于类的成员定义前,用来限定对象对该类成员的访问权限\")]),s._v(\" \"),t(\"li\",[s._v(\"4种权限可以用来修饰类及类的内部结构:属性,方法,构造器,内部类\")])]),s._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\",[t(\"strong\",[s._v(\"修饰符\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"类内部\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"同一个包下\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"不同包的子类\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"同一个工程\")])])])]),s._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[s._v(\"private\")]),s._v(\" \"),t(\"td\",[s._v(\"✔️\")]),s._v(\" \"),t(\"td\"),s._v(\" \"),t(\"td\"),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"(缺省)\")]),s._v(\" \"),t(\"td\",[s._v(\"✔️\")]),s._v(\" \"),t(\"td\",[s._v(\"✔️\")]),s._v(\" \"),t(\"td\"),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"protected\")]),s._v(\" \"),t(\"td\",[s._v(\"✔️\")]),s._v(\" \"),t(\"td\",[s._v(\"✔️\")]),s._v(\" \"),t(\"td\",[s._v(\"✔️\")]),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"public\")]),s._v(\" \"),t(\"td\",[s._v(\"✔️\")]),s._v(\" \"),t(\"td\",[s._v(\"✔️\")]),s._v(\" \"),t(\"td\",[s._v(\"✔️\")]),s._v(\" \"),t(\"td\",[s._v(\"✔️\")])])])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"对于class(类)的权限修饰只可以用public和default(缺省)\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"public类可以在任意地方被访问\")]),s._v(\" \"),t(\"li\",[s._v(\"default类只可以被同一个包内部的类访问\")])]),s._v(\" \"),t(\"h2\",{attrs:{id:\"继承\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#继承\"}},[s._v(\"#\")]),s._v(\" 继承\")]),s._v(\" \"),t(\"p\",[s._v(\"在谈到面向对象的时候，又不得不提到面向对象的三大特征：封装、\"),t(\"strong\",[s._v(\"继承\")]),s._v(\"、多态。三大特征紧密联系而又有区别，合理使用继承就能大大减少重复代码，\"),t(\"strong\",[s._v(\"提高代码复用性,也是使用多态的前提。\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"什么是继承\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是继承\"}},[s._v(\"#\")]),s._v(\" 什么是继承\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"继承\")]),s._v(\"（英语：inheritance）是面向对象软件技术中的一个概念。它使得\"),t(\"strong\",[s._v(\"复用以前的代码非常容易，能够大大缩短开发周期，降低开发费用。\")])]),s._v(\" \"),t(\"p\",[s._v(\"Java语言是非常典型的面向对象的语言，在Java语言中\"),t(\"strong\",[s._v(\"继承就是子类继承父类的属性和方法，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的方法\")]),s._v(\"。父类有时也叫基类、超类；子类有时也被称为派生类。\")]),s._v(\" \"),t(\"p\",[s._v(\"我们来举个例子：我们知道动物有很多种，是一个比较大的概念。在动物的种类中，我们熟悉的有猫(Cat)、狗(Dog)等动物，它们都有动物的一般特征 （比如能够吃东西，能够发出声音），不过又在细节上有区别（不同动物的吃的不同，叫声不一样）。在Java语言中实现Cat和Dog等类的时候，就需要继承Animal这个类。继承之后Cat、Dog等具体动物类就是子类，Animal类就是父类。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"如果我们没有显式的声明一个的父类的时候,那么它默认继承Object类!!!\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"所有的Java类都直接或者间接的继承Object类!!!\")])]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1606699914834-f234cb3b-1abe-456e-8f4f-725063a76386.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"h3\",{attrs:{id:\"为什么需要继承\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么需要继承\"}},[s._v(\"#\")]),s._v(\" 为什么需要继承\")]),s._v(\" \"),t(\"p\",[s._v(\"你可能会疑问\"),t(\"strong\",[s._v(\"为什么需要继承\")]),s._v(\"？在具体实现的时候，我们创建Dog，Cat等类的时候实现其具体的方法不就可以了嘛，实现这个继承似乎使得这个类的结构不那么清晰。\")]),s._v(\" \"),t(\"p\",[s._v(\"如果仅仅只有两三个类，每个类的属性和方法很有限的情况下确实没必要实现继承，但事情并非如此，事实上一个系统中往往有很多个类并且有着很多相似之处，比如猫和狗同属动物，或者学生和老师同属人。各个类可能又有很多个相同的属性和方法，这样的话如果每个类都重新写不仅代码显得很乱，代码工作量也很大。\")]),s._v(\" \"),t(\"p\",[s._v(\"这时继承的优势就出来了：可以直接使用父类的属性和方法，自己也可以有自己新的属性和方法满足拓展，父类的方法如果自己有需求更改也可以重写。这样\"),t(\"strong\",[s._v(\"使用继承不仅大大的减少了代码量，也使得代码结构更加清晰可见\")]),s._v(\"。\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1606699926783-d7954bab-0236-43b3-9a8e-2869a49938bc.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"p\",[s._v(\"所以这样从代码的层面上来看我们设计这个完整的Animal类是这样的：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v('class Animal\\n{\\n    public int id;\\n    public String name;\\n    public int age;\\n    public int weight;\\n    public Animal(int id, String name, int age, int weight) {\\n        this.id = id;\\n        this.name = name;\\n        this.age = age;\\n        this.weight = weight;\\n    }\\n    //这里省略get set方法\\n    public void sayHello()\\n    {\\n        System.out.println(\"hello\");\\n    }\\n    public void eat()\\n    {\\n        System.out.println(\"I\\'m eating\");\\n    }\\n    public void sing()\\n    {\\n        System.out.println(\"sing\");\\n    }\\n}\\n')])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"20\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"21\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"22\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"23\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"24\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"25\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"26\")]),t(\"br\")])]),t(\"p\",[s._v(\"而Dog，Cat，Chicken类可以这样设计：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v('class Dog extends Animal//继承animal\\n{\\n    public Dog(int id, String name, int age, int weight) {\\n        super(id, name, age, weight);//调用父类构造方法\\n    }\\n}\\nclass Cat extends Animal{\\n    public Cat(int id, String name, int age, int weight) {\\n        super(id, name, age, weight);//调用父类构造方法\\n    }\\n}\\nclass Chicken extends Animal{\\n    public Chicken(int id, String name, int age, int weight) {\\n        super(id, name, age, weight);//调用父类构造方法\\n    }\\n    //鸡下蛋\\n    public void layEggs()\\n    {\\n        System.out.println(\"我是老母鸡下蛋啦，咯哒咯！咯哒咯！\");\\n    }\\n}\\n')])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"20\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"21\")]),t(\"br\")])]),t(\"p\",[s._v(\"各自的类继承Animal后可以直接使用Animal类的属性和方法而不需要重复编写，各个类如果有自己的方法也可很容易地拓展。上述代码中你需要注意\"),t(\"strong\",[s._v(\"extends\")]),s._v(\"就是用来实现继承的。\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"继承的分类\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#继承的分类\"}},[s._v(\"#\")]),s._v(\" 继承的分类\")]),s._v(\" \"),t(\"p\",[s._v(\"继承分为单继承和多继承，Java语言只支持类的单继承，但可以通过实现接口的方式达到多继承的目的。\"),t(\"strong\",[s._v(\"我们先用一张表概述一下两者的区别，然后再展开讲解。\")])]),s._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\"),s._v(\" \"),t(\"th\",[s._v(\"定义\")]),s._v(\" \"),t(\"th\",[s._v(\"优缺点\")])])]),s._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[s._v(\"单继承 \"),t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2021/webp/1158395/1610374882265-48662d0e-fa6b-499f-b53b-eb80499ce529.webp\",alt:\"image\"}})]),s._v(\" \"),t(\"td\",[s._v(\"一个子类只拥有一个父类\")]),s._v(\" \"),t(\"td\",[s._v(\"优点：在类层次结构上比较清晰 缺点：结构的丰富度有时不能满足使用需求\")])]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"多继承（Java不支持，但可以用其它方式满足多继承使用需求） \"),t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2021/webp/1158395/1610374882099-1925f870-fe2b-4a0c-8c25-3eeddb8ba689.webp\",alt:\"image\"}})]),s._v(\" \"),t(\"td\",[s._v(\"一个子类拥有多个直接的父类\")]),s._v(\" \"),t(\"td\",[s._v(\"优点：子类的丰富度很高 缺点：容易造成混乱\")])])])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"单继承\")])]),s._v(\" \"),t(\"p\",[s._v(\"单继承，是一个子类只拥有一个父类，如我们上面讲过的Animal类和它的子类。\"),t(\"strong\",[s._v(\"单继承在类层次结构上比较清晰，但缺点是结构的丰富度有时不能满足使用需求\")]),s._v(\"。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"多继承\")]),s._v(\"(Java不支持，但可以实现)\")]),s._v(\" \"),t(\"p\",[s._v(\"多继承，是一个子类拥有多个直接的父类。这样做的好处是子类拥有所有父类的特征，\"),t(\"strong\",[s._v(\"子类的丰富度很高，但是缺点就是容易造成混乱\")]),s._v(\"。下图为一个混乱的例子。\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1606699944387-75629f6f-866c-4533-8214-a9167545c794.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"p\",[s._v(\"Java虽然不支持多继承，但是Java有三种实现多继承效果的方式，\"),t(\"strong\",[s._v(\"分别是\")]),s._v(\"内部类、多层继承和实现接口。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"内部类\")]),s._v(\"可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，可以达到多继承的效果。\")]),s._v(\" \"),t(\"p\",[s._v(\"**多层继承：*\"),t(\"em\",[s._v(\"子类继承父类，父类如果还继承其他的类，那么这就叫*\"),t(\"em\",[s._v(\"多层继承\")])]),s._v(\"。这样子类就会拥有所有被继承类的属性和方法。\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1606699960776-cc4e4427-20ce-4e93-898b-6744585e1eff.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"实现接口\")]),s._v(\"无疑是满足多继承使用需求的最好方式，一个类可以实现多个接口满足自己在丰富性和复杂环境的使用需求。类和接口相比，\"),t(\"strong\",[s._v(\"类就是一个实体，有属性和方法，而接口更倾向于一组方法\")]),s._v(\"。举个例子，就拿斗罗大陆的唐三来看，他存在的继承关系可能是这样的：\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1606699975032-942a1afc-2bf6-49c7-9c8c-ab1d9f150573.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"h3\",{attrs:{id:\"如何实现继承\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何实现继承\"}},[s._v(\"#\")]),s._v(\" 如何实现继承\")]),s._v(\" \"),t(\"p\",[s._v(\"实现继承\"),t(\"strong\",[s._v(\"除了上面用到的extends\")]),s._v(\"外，还可以用implements这个关键字实现。下面，让我给你逐一讲解一下。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"extends关键字\")])]),s._v(\" \"),t(\"p\",[s._v(\"在Java中，类的继承是单一继承，也就是说一个子类只能拥有一个父类，所以\"),t(\"strong\",[s._v(\"extends\")]),s._v(\"只能继承一个类。其使用语法为：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"class 子类名 extends 父类名{}\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\")])]),t(\"p\",[s._v(\"例如Dog类继承Animal类，它是这样的：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"class Animal{} //定义Animal类\\nclass Dog extends Animal{} //Dog类继承Animal类\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\")])]),t(\"p\",[s._v(\"子类继承父类后，就拥有父类的非私有的\"),t(\"strong\",[s._v(\"属性和方法\")]),s._v(\"。如果不明白，请看这个案例，在IDEA下创建一个项目，创建一个test类做测试，分别创建Animal类和Dog类，Animal作为父类写一个sayHello()方法，Dog类继承Animal类之后就可以调用sayHello()方法。具体代码为：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v('class Animal {\\n    public void  sayHello()//父类的方法\\n    {\\n        System.out.println(\"hello,everybody\");\\n    }\\n}\\nclass Dog extends Animal//继承animal\\n{ }\\npublic class test {\\n    public static void main(String[] args) {\\n       Dog dog=new Dog();\\n       dog.sayHello();\\n    }\\n}\\n')])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\")])]),t(\"p\",[s._v(\"点击运行的时候Dog子类可以直接使用Animal父类的方法。\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/webp/1158395/1606699861649-6fcb1f9e-0fd1-4b48-99e8-dfe20929e826.webp\",alt:\"image\"}})]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"implements 关键字\")])]),s._v(\" \"),t(\"p\",[s._v(\"使用implements 关键字可以变相使Java拥有多继承的特性，使用范围为类实现接口的情况，一个类可以实现多个接口(接口与接口之间用逗号分开)。Java接口是一系列方法的声明，\"),t(\"strong\",[s._v(\"一个接口中没有方法的具体实现\")]),s._v(\" 。子类实现接口的时候必须重写接口中的方法。\")]),s._v(\" \"),t(\"p\",[s._v(\"我们来看一个案例，创建一个test2类做测试，分别创建doA接口和doB接口，doA接口声明sayHello()方法，doB接口声明eat()方法，创建Cat2类实现doA和doB接口，并且在类中需要重写sayHello()方法和eat()方法。具体代码为：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v('interface doA{\\n     void sayHello();\\n}\\ninterface doB{\\n     void eat();\\n    //以下会报错 接口中的方法不能具体定义只能声明\\n    //public void eat(){System.out.println(\"eating\");}\\n}\\nclass Cat2 implements  doA,doB{\\n    @Override//必须重写接口内的方法\\n    public void sayHello() {\\n        System.out.println(\"hello!\");\\n    }\\n    @Override\\n    public void eat() {\\n        System.out.println(\"I\\'m eating\");\\n    }\\n}\\npublic class test2 {\\n    public static void main(String[] args) {\\n        Cat2 cat=new Cat2();\\n        cat.sayHello();\\n        cat.eat();\\n    }\\n}\\n')])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"20\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"21\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"22\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"23\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"24\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"25\")]),t(\"br\")])]),t(\"p\",[s._v(\"Cat类实现doA和doB接口的时候，需要实现其声明的方法，点击运行结果如下，这就是一个类实现接口的简单案例：\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/webp/1158395/1606699861529-f708ce25-8b9c-428b-8398-01179c2bb930.webp\",alt:\"image\"}})]),s._v(\" \"),t(\"h2\",{attrs:{id:\"继承的特点\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#继承的特点\"}},[s._v(\"#\")]),s._v(\" 继承的特点\")]),s._v(\" \"),t(\"p\",[s._v(\"继承的主要内容就是子类继承父类，并重写父类的方法。使用子类的属性或方法时候，首先要创建一个对象，而对象通过\"),t(\"strong\",[s._v(\"构造方法\")]),s._v(\"去创建，在构造方法中我们可能会调用子父类的一些属性和方法，所以就需要提前掌握\"),t(\"strong\",[s._v(\"this和super\")]),s._v(\"关键字。创建完这个对象之后，在调用\"),t(\"strong\",[s._v(\"重写\")]),s._v(\"父类的方法，并区别重写和重载的区别。所以本节根据this、super关键字—>构造函数—>方法重写—>方法重载的顺序进行讲解。\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"this和super关键字\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#this和super关键字\"}},[s._v(\"#\")]),s._v(\" this和super关键字\")]),s._v(\" \"),t(\"p\",[s._v(\"this和super关键字是继承中\"),t(\"strong\",[s._v(\"非常重要的知识点\")]),s._v(\"，分别表示当前对象的引用和父类对象的引用，两者有很大相似又有一些区别。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"this表示当前对象，是指向自己的引用。\")])]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"this.属性 // 调用成员变量，要区别成员变量和局部变量\\nthis.() // 调用本类的某个方法\\nthis() // 表示调用本类构造方法\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\")])]),t(\"p\",[t(\"strong\",[s._v(\"super表示父类对象，是指向父类的引用。\")])]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"super.属性 // 表示父类对象中的成员变量\\nsuper.方法() // 表示父类对象中定义的方法\\nsuper() // 表示调用父类构造方法\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\")])]),t(\"p\",[t(\"strong\",[s._v(\"在子类中调用方法的时候,先回在子类中找,如果子类没有,则会在父类中找,可以不写this或者super\")])]),s._v(\" \"),t(\"p\",[s._v(\"此外，this和super关键字只能出现在非static修饰的代码中。\")]),s._v(\" \"),t(\"p\",[s._v(\"this()和super()都只能在\"),t(\"strong\",[s._v(\"构造方法\")]),s._v(\"的第一行出现，如果使用this()表示调用当前类的其他构造方法，使用super()表示调用父类的某个构造方法，所以两者只能根据自己使用需求选择其一。\")]),s._v(\" \"),t(\"p\",[s._v(\"写一个小案例，创建D1类和子类D2如下：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v('class D1{\\n    public D1() {}//无参构造\\n    public void sayHello() {\\n        System.out.println(\"hello\");\\n    }\\n}\\nclass D2 extends D1{\\n    public String name;\\n    public D2(){\\n        super();//调用父类构造方法\\n        this.name=\"BigSai\";//给当前类成员变量赋值\\n    }\\n    @Override\\n    public void sayHello() {\\n        System.out.println(\"hello，我是\"+this.name);\\n    }\\n    public void test()\\n    {\\n        super.sayHello();//调用父类方法\\n        this.sayHello();//调用当前类其他方法\\n    }\\n}\\npublic class test8 {\\n    public static void main(String[] args) {\\n        D2 d2=new D2();\\n        d2.test();\\n    }\\n}\\n')])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"20\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"21\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"22\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"23\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"24\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"25\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"26\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"27\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"28\")]),t(\"br\")])]),t(\"p\",[s._v(\"执行的结果为：\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/webp/1158395/1606699861582-6384a18c-3bf3-4010-8831-bc0de3374b3b.webp\",alt:\"image\"}})]),s._v(\" \"),t(\"h3\",{attrs:{id:\"构造方法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#构造方法\"}},[s._v(\"#\")]),s._v(\" 构造方法\")]),s._v(\" \"),t(\"p\",[s._v(\"构造方法是一种特殊的方法，\"),t(\"strong\",[s._v(\"它是一个与类同名的方法\")]),s._v(\"。对象的创建就通过构造方法来完成，其主要的功能是完成对象的初始化。但在继承中\"),t(\"strong\",[s._v(\"构造方法是一种比较特殊的方法\")]),s._v(\"（比如不能继承），所以要了解和学习在继承中构造方法的规则和要求。\")]),s._v(\" \"),t(\"p\",[s._v(\"构造方法可分为有参构造和无参构造，这个可以根据自己的使用需求合理设置构造方法。但继承中的构造方法有以下几点需要注意：\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"父类的构造方法不能被继承：\")])]),s._v(\" \"),t(\"p\",[s._v(\"因为构造方法语法是\"),t(\"strong\",[s._v(\"与类同名\")]),s._v(\"，而继承则不更改方法名，如果子类继承父类的构造方法，那明显与构造方法的语法冲突了。比如Father类的构造方法名为Father()，Son类如果继承Father类的构造方法Father()，那就和构造方法定义：\"),t(\"strong\",[s._v(\"构造方法与类同名\")]),s._v(\"冲突了，所以在子类中不能继承父类的构造方法，但子类会调用父类的构造方法。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"子类的构造过程必须调用其父类的构造方法：\")])]),s._v(\" \"),t(\"p\",[s._v(\"Java虚拟机**构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，*\"),t(\"em\",[s._v(\"这被称为*\"),t(\"em\",[s._v(\"内存叠加\")])]),s._v(\"。而Java虚拟机构造父类对象会执行父类的构造方法，所以子类构造方法必须调用super()即父类的构造方法。就比如一个简单的继承案例应该这么写：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"class A{\\n    public String name;\\n    public A() {//无参构造\\n    }\\n    public A (String name){//有参构造\\n    }\\n}\\nclass B extends A{\\n    public B() {//无参构造\\n       super();\\n    }\\n    public B(String name) {//有参构造\\n      //super();\\n       super(name);\\n    }\\n}\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),t(\"br\")])]),t(\"p\",[t(\"strong\",[s._v(\"如果子类的构造方法中没有显示地调用父类构造方法，则系统默认调用父类无参数的构造方法。\")])]),s._v(\" \"),t(\"p\",[s._v(\"你可能有时候在写继承的时候子类并没有使用super()调用，程序依然没问题，其实这样是为了节省代码，系统执行时会自动添加父类的无参构造方式，如果不信的话我们对上面的类稍作修改执行：\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/webp/1158395/1606699861586-cda5ac17-44f4-4810-8689-de37d6f621ac.webp\",alt:\"image\"}})]),s._v(\" \"),t(\"h3\",{attrs:{id:\"方法重写-override\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#方法重写-override\"}},[s._v(\"#\")]),s._v(\" 方法重写(Override)\")]),s._v(\" \"),t(\"p\",[s._v(\"方法重写也就是子类中出现和父类中一模一样的方法(包括返回值类型，方法名，参数列表)，它建立在继承的基础上。你可以理解为方法的\"),t(\"strong\",[s._v(\"外壳不变，但是核心内容重写\")]),s._v(\"。\")]),s._v(\" \"),t(\"p\",[s._v(\"在这里提供一个简单易懂的方法重写案例：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v('class E1{\\n    public void doA(int a){\\n        System.out.println(\"这是父类的方法\");\\n    }\\n}\\nclass E2 extends E1{\\n    @Override\\n    public void doA(int a) {\\n        System.out.println(\"我重写父类方法，这是子类的方法\");\\n    }\\n}\\n')])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\")])]),t(\"p\",[s._v(\"其中@Override注解显示声明该方法为注解方法，可以帮你检查重写方法的语法正确性，当然如果不加也是可以的，但建议加上。\")]),s._v(\" \"),t(\"p\",[s._v(\"对于重写，你需要注意以下几点：\")]),s._v(\" \"),t(\"p\",[s._v(\"从重写的要求上看：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"重写的方法和父类的要一致(包括返回值类型、方法名、参数列表)\")]),s._v(\" \"),t(\"li\",[s._v(\"方法重写只存在于子类和父类之间，同一个类中只能重载\")])]),s._v(\" \"),t(\"p\",[s._v(\"从访问权限上看：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"子类方法不能缩小父类方法的访问权限\")]),s._v(\" \"),t(\"li\",[s._v(\"子类方法不能抛出比父类方法更多的异常\")]),s._v(\" \"),t(\"li\",[s._v(\"父类的私有方法不能被子类重写\")])]),s._v(\" \"),t(\"p\",[s._v(\"从静态和非静态上看：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"父类的静态方法不能被子类重写为非静态方法\")]),s._v(\" \"),t(\"li\",[s._v(\"子类可以定义于父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法（满足重写约束）\")]),s._v(\" \"),t(\"li\",[s._v(\"父类的非静态方法不能被子类重写为静态方法\")])]),s._v(\" \"),t(\"p\",[s._v(\"从抽象和非抽象来看：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"父类的抽象方法可以被子类通过两种途径重写（即实现和重写）\")]),s._v(\" \"),t(\"li\",[s._v(\"父类的非抽象方法可以被重写为抽象方法\")])]),s._v(\" \"),t(\"p\",[s._v(\"当然，这些规则可能涉及一些修饰符，在第三关中会详细介绍。\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"方法重载-overload\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#方法重载-overload\"}},[s._v(\"#\")]),s._v(\" 方法重载(Overload)\")]),s._v(\" \"),t(\"p\",[s._v(\"如果有两个方法的\"),t(\"strong\",[s._v(\"方法名相同\")]),s._v(\"，但参数不一致，那么可以说一个方法是另一个方法的重载。方法重载规则如下：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"被重载的方法\"),t(\"strong\",[s._v(\"必须改变参数列表\")]),s._v(\"(参数个数或类型或顺序不一样)\")]),s._v(\" \"),t(\"li\",[s._v(\"被重载的方法可以改变返回类型\")]),s._v(\" \"),t(\"li\",[s._v(\"被重载的方法可以改变访问修饰符\")]),s._v(\" \"),t(\"li\",[s._v(\"被重载的方法可以声明新的或更广的检查异常\")]),s._v(\" \"),t(\"li\",[s._v(\"方法能够在同一个类中或者在一个子类中被重载\")]),s._v(\" \"),t(\"li\",[s._v(\"无法以返回值类型作为重载函数的区分标准\")])]),s._v(\" \"),t(\"p\",[s._v(\"重载可以通常理解为完成同一个事情的方法名相同，但是参数列表不同其他条件也可能不同。一个简单的方法重载的例子，类E3中的add()方法就是一个重载方法。\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"class E3{\\n    public int add(int a,int b){\\n        return a+b;\\n    }\\n    public double add(double a,double b) {\\n        return a+b;\\n    }\\n    public int add(int a,int b,int c) {\\n        return a+b+c;\\n    }\\n}\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\")])]),t(\"p\",[t(\"strong\",[s._v(\"方法重写和方法重载的区别\")]),s._v(\"：\")]),s._v(\" \"),t(\"p\",[s._v(\"方法重写和方法重载名称上容易混淆，但内容上有很大区别，下面用一个表格列出其中区别：\")]),s._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\",[s._v(\"区别点\")]),s._v(\" \"),t(\"th\",[s._v(\"方法重写\")]),s._v(\" \"),t(\"th\",[s._v(\"方法重载\")])])]),s._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[s._v(\"结构上\")]),s._v(\" \"),t(\"td\",[s._v(\"垂直结构，是一种父子类之间的关系\")]),s._v(\" \"),t(\"td\",[s._v(\"水平结构，是一种同类之间关系\")])]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"参数列表\")]),s._v(\" \"),t(\"td\",[s._v(\"不可以修改\")]),s._v(\" \"),t(\"td\",[s._v(\"可以修改\")])]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"访问修饰符\")]),s._v(\" \"),t(\"td\",[s._v(\"子类的访问修饰符范围必须大于等于父类访问修饰符范围\")]),s._v(\" \"),t(\"td\",[s._v(\"可以修改\")])]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"抛出异常\")]),s._v(\" \"),t(\"td\",[s._v(\"子类方法异常必须是父类方法异常或父类方法异常子异常\")]),s._v(\" \"),t(\"td\",[s._v(\"可以修改\")])])])]),s._v(\" \"),t(\"h2\",{attrs:{id:\"继承与修饰符\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#继承与修饰符\"}},[s._v(\"#\")]),s._v(\" 继承与修饰符\")]),s._v(\" \"),t(\"p\",[s._v(\"Java修饰符的作用就是对类或类成员进行修饰或限制，每个修饰符都有自己的作用，而在继承中可能有些特殊修饰符使得被修饰的属性或方法不能被继承，或者继承需要一些其他的条件，下面就详细介绍在继承中一些修饰符的作用和特性。\")]),s._v(\" \"),t(\"p\",[s._v(\"Java语言提供了很多修饰符，修饰符用来定义类、方法或者变量，通常放在语句的最前端。主要分为以下两类：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"访问修饰符\")]),s._v(\" \"),t(\"li\",[s._v(\"非访问修饰符\")])]),s._v(\" \"),t(\"p\",[s._v(\"这里访问修饰符主要讲解public，protected，default，private四种访问控制修饰符。非访问修饰符这里就介绍static修饰符，final修饰符和abstract修饰符。\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"访问修饰符\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#访问修饰符\"}},[s._v(\"#\")]),s._v(\" 访问修饰符\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"public，protected，default(无修饰词)，private\")]),s._v(\"修饰符是面向对象中非常重要的知识点，而在继承中也需要懂得各种修饰符使用规则。\")]),s._v(\" \"),t(\"p\",[s._v(\"首先我们都知道不同的关键字作用域不同，四种关键字的作用域如下：\")]),s._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\"),s._v(\" \"),t(\"th\",[s._v(\"同一个类\")]),s._v(\" \"),t(\"th\",[s._v(\"同一个包\")]),s._v(\" \"),t(\"th\",[s._v(\"不同包子类\")]),s._v(\" \"),t(\"th\",[s._v(\"不同包非子类\")])])]),s._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[s._v(\"private\")]),s._v(\" \"),t(\"td\",[s._v(\"✅\")]),s._v(\" \"),t(\"td\"),s._v(\" \"),t(\"td\"),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"default\")]),s._v(\" \"),t(\"td\",[s._v(\"✅\")]),s._v(\" \"),t(\"td\",[s._v(\"✅\")]),s._v(\" \"),t(\"td\"),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"protect\")]),s._v(\" \"),t(\"td\",[s._v(\"✅\")]),s._v(\" \"),t(\"td\",[s._v(\"✅\")]),s._v(\" \"),t(\"td\",[s._v(\"✅\")]),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"public\")]),s._v(\" \"),t(\"td\",[s._v(\"✅\")]),s._v(\" \"),t(\"td\",[s._v(\"✅\")]),s._v(\" \"),t(\"td\",[s._v(\"✅\")]),s._v(\" \"),t(\"td\",[s._v(\"✅\")])])])]),s._v(\" \"),t(\"ol\",[t(\"li\",[s._v(\"private：Java语言中对访问权限限制的\"),t(\"strong\",[s._v(\"最窄\")]),s._v(\"的修饰符，一般称之为“私有的”。被其修饰的属性以及方法\"),t(\"strong\",[s._v(\"只能被该类的对象访问\")]),s._v(\"，其子类不能访问，更不能允许跨包访问。\")]),s._v(\" \"),t(\"li\",[s._v(\"default：(也有称friendly)\"),t(\"strong\",[s._v(\"即不加任何访问修饰符\")]),s._v(\"，通常称为“默认访问权限“或者“包访问权限”。该模式下，只允许在同一个包中进行访问。\")]),s._v(\" \"),t(\"li\",[s._v(\"protected：介于public 和 private 之间的一种访问修饰符，一般称之为“保护访问权限”。被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。\")]),s._v(\" \"),t(\"li\",[s._v(\"public：Java语言中访问限制\"),t(\"strong\",[s._v(\"最宽\")]),s._v(\"的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包访问。\")])]),s._v(\" \"),t(\"p\",[s._v(\"Java 子类重写继承的方法时，\"),t(\"strong\",[s._v(\"不可以降低方法的访问权限\")]),s._v(\"，\"),t(\"strong\",[s._v(\"子类继承父类的访问修饰符作用域不能比父类小\")]),s._v(\"，也就是更加开放，假如父类是protected修饰的，其子类只能是protected或者public，绝对不能是default(默认的访问范围)或者private。所以在继承中需要重写的方法不能使用private修饰词修饰。\")]),s._v(\" \"),t(\"p\",[s._v(\"如果还是不太清楚可以看几个小案例就很容易搞懂，写一个A1类中用四种修饰词实现四个方法，用子类A2继承A1，重写A1方法时候你就会发现父类私有方法不能重写，非私有方法重写使用的修饰符作用域不能变小(大于等于)。\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/webp/1158395/1606699861508-393056dd-6440-4269-a3c2-bb1020164a3f.webp\",alt:\"image\"}})]),s._v(\" \"),t(\"p\",[s._v(\"正确的案例应该为：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"class A1 {\\n    private void doA(){ }\\n    void doB(){}//default\\n    protected void doC(){}\\n    public void doD(){}\\n}\\nclass A2 extends A1{\\n    @Override\\n    public void doB() { }//继承子类重写的方法访问修饰符权限可扩大\\n    @Override\\n    protected void doC() { }//继承子类重写的方法访问修饰符权限可和父类一致\\n    @Override\\n    public void doD() { }//不可用protected或者default修饰\\n}\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\")])]),t(\"p\",[s._v(\"还要注意的是，\"),t(\"strong\",[s._v(\"继承当中子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常\")]),s._v(\"。下面的一个案例四种方法测试可以发现子类方法的异常不可大于父类对应方法抛出异常的范围。\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/webp/1158395/1606699861549-8cba046e-4c39-4e89-b07c-2e69edcbec84.webp\",alt:\"image\"}})]),s._v(\" \"),t(\"p\",[s._v(\"正确的案例应该为：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"class B1{\\n    public void doA() throws Exception{}\\n    public void doB() throws Exception{}\\n    public void doC() throws IOException{}\\n    public void doD() throws IOException{}\\n}\\nclass B2 extends B1{\\n    //异常范围和父类可以一致\\n    @Override\\n    public void doA() throws Exception { }\\n    //异常范围可以比父类更小\\n    @Override\\n    public void doB() throws IOException { }\\n    //异常范围 不可以比父类范围更大\\n    @Override\\n    public void doC() throws IOException { }//不可抛出Exception等比IOException更大的异常\\n    @Override\\n    public void doD() throws IOException { }\\n}\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),t(\"br\")])]),t(\"h3\",{attrs:{id:\"非访问修饰符\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#非访问修饰符\"}},[s._v(\"#\")]),s._v(\" 非访问修饰符\")]),s._v(\" \"),t(\"p\",[s._v(\"访问修饰符用来控制访问权限，而非访问修饰符每个都有各自的作用，下面针对static、final、abstract修饰符进行介绍。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"static 修饰符\")])]),s._v(\" \"),t(\"p\",[s._v(\"static 翻译为“静态的”，能够与变量，方法和类一起使用，\"),t(\"strong\",[s._v(\"称为静态变量，静态方法(也称为类变量、类方法)\")]),s._v(\"。如果在一个类中使用static修饰变量或者方法的话，它们\"),t(\"strong\",[s._v(\"可以直接通过类访问，不需要创建一个类的对象来访问成员。\")])]),s._v(\" \"),t(\"p\",[s._v(\"我们在设计类的时候可能会使用静态方法，有很多工具类比如\"),t(\"code\",[s._v(\"Math\")]),s._v(\"，\"),t(\"code\",[s._v(\"Arrays\")]),s._v(\"等类里面就写了很多静态方法。static修饰符的规则很多，这里仅仅介绍和Java继承相关用法的规则：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"构造方法不允许声明为 static 的。\")]),s._v(\" \"),t(\"li\",[s._v(\"静态方法中不存在当前对象，因而不能使用 this，当然也不能使用 super。\")]),s._v(\" \"),t(\"li\",[s._v(\"静态方法不能被非静态方法重写(覆盖)\")]),s._v(\" \"),t(\"li\",[s._v(\"静态方法能被静态方法重写(覆盖)\")])]),s._v(\" \"),t(\"p\",[s._v(\"可以看以下的案例证明上述规则：\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/webp/1158395/1606699861531-fd97c69c-728c-405c-8a38-7223ecd84c25.webp\",alt:\"image\"}})]),s._v(\" \"),t(\"p\",[s._v(\"源代码为：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"class C1{\\n    public  int a;\\n    public C1(){}\\n   // public static C1(){}// 构造方法不允许被声明为static\\n    public static void doA() {}\\n    public static void doB() {}\\n}\\nclass C2 extends C1{\\n    public static  void doC()//静态方法中不存在当前对象，因而不能使用this和super。\\n    {\\n        //System.out.println(super.a);\\n    }\\n    public static void doA(){}//静态方法能被静态方法重写\\n   // public void doB(){}//静态方法不能被非静态方法重写\\n}\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\")])]),t(\"p\",[t(\"strong\",[s._v(\"final修饰符\")])]),s._v(\" \"),t(\"p\",[s._v(\"final变量：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v('final 表示\"最后的、最终的\"含义，'),t(\"strong\",[s._v(\"变量一旦赋值后，不能被重新赋值\")]),s._v(\"。被 final 修饰的实例变量必须显式指定初始值(即不能只声明)。final 修饰符通常和 static 修饰符一起使用来创建类常量。\")])]),s._v(\" \"),t(\"p\",[s._v(\"final 方法：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[s._v(\"父类中的 final 方法可以被子类继承，但是不能被子类重写\")]),s._v(\"。声明 final 方法的主要目的是防止该方法的内容被修改。\")])]),s._v(\" \"),t(\"p\",[s._v(\"final类：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[s._v(\"final 类不能被继承\")]),s._v(\"，没有类能够继承 final 类的任何特性。\")])]),s._v(\" \"),t(\"p\",[s._v(\"所以无论是变量、方法还是类被final修饰之后，都有代表最终、最后的意思。内容无法被修改。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"abstract 修饰符\")])]),s._v(\" \"),t(\"p\",[s._v(\"abstract 英文名为“抽象的”，主要用来修饰类和方法，称为抽象类和抽象方法。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"抽象方法\")]),s._v(\"：有很多不同类的方法是相似的，但是具体内容又不太一样，所以我们只能抽取他的声明，没有具体的方法体，即抽象方法可以表达概念但无法具体实现。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"抽象类\")]),s._v(\"：\"),t(\"strong\",[s._v(\"有抽象方法的类必须是抽象类\")]),s._v(\"，抽象类可以表达概念但是无法构造实体的类。\")]),s._v(\" \"),t(\"p\",[s._v(\"抽象类和抽象方法内容和规则比较多。这里只提及一些和继承有关的用法和规则：\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"抽象类也是类，如果一个类继承于抽象类，就不能继承于其他的（类或抽象类）\")]),s._v(\" \"),t(\"li\",[s._v(\"子类可以继承于抽象类，但是一定要实现父类们所有abstract的方法。如果不能完全实现，那么子类也必须被定义为抽象类\")]),s._v(\" \"),t(\"li\",[s._v(\"只有实现父类的所有抽象方法，才能是完整类。\")])]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1606700003999-eaa5ca93-3c38-4e7f-95cf-dea5990ae4f7.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"p\",[s._v(\"比如我们可以这样设计一个People抽象类以及一个抽象方法，在子类中具体完成：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v('abstract class People{\\n    public abstract void sayHello();//抽象方法\\n}\\nclass Chinese extends People{\\n    @Override\\n    public void sayHello() {//实现抽象方法\\n        System.out.println(\"你好\");\\n    }\\n}\\nclass Japanese extends People{\\n    @Override\\n    public void sayHello() {//实现抽象方法\\n        System.out.println(\"口你七哇\");\\n    }\\n}\\nclass American extends People{\\n    @Override\\n    public void sayHello() {//实现抽象方法\\n        System.out.println(\"hello\");\\n    }\\n}\\n')])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"20\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"21\")]),t(\"br\")])]),t(\"p\",[s._v(\"提到Java继承，不得不提及所有类的根类：Object(java.lang.Object)类，如果一个类没有显式声明它的父类（即没有写extends xx），那么默认这个类的父类就是Object类，任何类都可以使用Object类的方法，创建的类也可和Object进行向上、向下转型，所以Object类是掌握和理解继承所必须的知识点。而Java向上和向下转型在Java中运用很多，也是建立在继承的基础上，所以Java转型也是掌握和理解继承所必须的知识点。\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"多态性\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#多态性\"}},[s._v(\"#\")]),s._v(\" 多态性\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"概念\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#概念\"}},[s._v(\"#\")]),s._v(\" 概念\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"可以理解为一个事务的多种形态\")]),s._v(\" \"),t(\"li\",[s._v(\"父类的引用指向子类的对象(或者子类的对象赋给父类的引用)\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"使用\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用\"}},[s._v(\"#\")]),s._v(\" 使用\")]),s._v(\" \"),t(\"p\",[s._v(\"当调用子父类同名同参数的方法时,实际执行的是子类重写父类的方法-虚拟方法调用\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"特征\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#特征\"}},[s._v(\"#\")]),s._v(\" 特征\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"方法-编译的时候看左边,父类中是否声明该方法,运行看右边,真正执行的是子类重写后的方法\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"属性-编译看左右边,运行也是看左边,子父类存在相同的属性时候,不存在覆盖\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"好处\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#好处\"}},[s._v(\"#\")]),s._v(\" 好处\")]),s._v(\" \"),t(\"p\",[s._v(\"可以去设计通用的接口,形参为父类,方法内部可以使用父类的方法,但实际传参都是子类,不同的子类根据需求去重写自己的方法实现,减少的子类重载方法的实现,例如数据库连接驱动,不同厂商根据自己的需求,去实现同一个父类\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"object类概述\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#object类概述\"}},[s._v(\"#\")]),s._v(\" Object类概述\")]),s._v(\" \"),t(\"ol\",[t(\"li\",[s._v(\"Object是类层次结构的\"),t(\"strong\",[s._v(\"根类\")]),s._v(\"，所有的类都隐式的继承自Object类。\")]),s._v(\" \"),t(\"li\",[s._v(\"Java所有的对象都拥有Object默认方法\")]),s._v(\" \"),t(\"li\",[s._v(\"Object类的构造方法有一个，并且是\"),t(\"strong\",[s._v(\"无参构造\")])])]),s._v(\" \"),t(\"p\",[s._v(\"Object是java所有类的父类，是整个类继承结构的顶端，也是最抽象的一个类。像toString()、equals()、hashCode()、wait()、notify()、getClass()等都是Object的方法。你以后可能会经常碰到，但其中遇到更多的就是toString()方法和equals()方法，我们经常需要重写这两种方法满足我们的使用需求。\")]),s._v(\" \"),t(\"p\",[s._v(\"**toString()**方法表示返回该对象的字符串，由于各个对象构造不同所以需要重写，如果不重写的话默认返回\"),t(\"code\",[s._v(\"类名@hashCode\")]),s._v(\"格式。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"如果重写toString()方法后\")]),s._v(\"直接调用toString()方法就可以返回我们自定义的该类转成字符串类型的内容输出，而不需要每次都手动的拼凑成字符串内容输出，大大简化输出操作。\")]),s._v(\" \"),t(\"p\",[s._v(\"**equals()\"),t(\"strong\",[s._v(\"方法主要比较两个对象是否相等，因为对象的相等不一定非要严格要求两个对象地址上的相同，有时内容上的相同我们就会认为它相等，比如String 类就重写了\")]),s._v(\"euqals()**方法，通过字符串的内容比较是否相等。\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/webp/1158395/1606699861622-831e43a6-664f-4e8e-a059-2acc8fcd3656.webp\",alt:\"image\"}})]),s._v(\" \"),t(\"p\",[s._v(\"**\\n**\")]),s._v(\" \"),t(\"p\",[s._v(\"**\\n**\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"有了多态性以后,内存中实际上是存在子类特有的方法和属性的,那如何去调用子类特有的属性和方法呢?引出了向上,向下转型\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"向上转型\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#向上转型\"}},[s._v(\"#\")]),s._v(\" 向上转型\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"向上转型\")]),s._v(\" : 通过子类对象实例化父类对象，这种属于自动转换。用一张图就能很好地表示向上转型的逻辑：\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/webp/1158395/1606699861589-25195b54-370d-4c18-87f5-72ac27908b34.webp\",alt:\"image\"}})]),s._v(\" \"),t(\"p\",[s._v(\"父类引用变量指向子类对象后，只能使用父类已声明的方法，但方法如果被重写会执行子类的方法，如果方法未被重写那么将执行父类的方法。\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"向下转型\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#向下转型\"}},[s._v(\"#\")]),s._v(\" 向下转型\")]),s._v(\" \"),t(\"h4\",{attrs:{id:\"为什么要向下转型\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么要向下转型\"}},[s._v(\"#\")]),s._v(\" 为什么要向下转型?:\")]),s._v(\" \"),t(\"p\",[s._v(\"有了对象的多态性以后,内存中实际存在的是子类特有的属性和方法,但是由于变量声明的是父类类型,导致编译时,只能调用父类的属性和方法,子类特有的属性和方法不能调用,所以才需要向下转型\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"向下转型\")]),s._v(\" : 通过父类对象实例化子类对象，在书写上父类对象需要加括号\"),t(\"code\",[s._v(\"()\")]),s._v(\"强制转换为子类类型。但父类引用变量实际引用必须是子类对象才能成功转型，这里也用一张图就能很好表示向上转型的逻辑：\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/webp/1158395/1606699861579-715ea1d3-b38c-493c-b3d5-0de7c247a892.webp\",alt:\"image\"}})]),s._v(\" \"),t(\"p\",[s._v(\"子类引用变量指向父类引用变量指向的对象后(一个Son()对象)，就完成向下转型，就可以调用一些子类特有而父类没有的方法 。\")]),s._v(\" \"),t(\"p\",[s._v(\"在这里写一个向上转型和向下转型的案例：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"Object object=new Integer(666);//向上转型\\nInteger i=(Integer)object;//向下转型Object->Integer，object的实质还是指向Integer\\nString str=(String)object;//错误的向下转型，虽然编译器不会报错但是运行会报错\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\")])]),t(\"h3\",{attrs:{id:\"instanceof\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#instanceof\"}},[s._v(\"#\")]),s._v(\" instanceof\")]),s._v(\" \"),t(\"p\",[s._v(\"要求a与A必须存在一个子父类的关系,否则会编译错误\")]),s._v(\" \"),t(\"p\",[s._v(\"a instanceof A :判断对象a是否是类A的一个实例\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#\"}},[s._v(\"#\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"-2\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#-2\"}},[s._v(\"#\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"-3\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#-3\"}},[s._v(\"#\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"-4\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#-4\"}},[s._v(\"#\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"父类初始化序\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#父类初始化序\"}},[s._v(\"#\")]),s._v(\" 父类初始化序\")]),s._v(\" \"),t(\"p\",[s._v(\"在Java继承中，父子类初始化先后顺序为：\")]),s._v(\" \"),t(\"ol\",[t(\"li\",[s._v(\"父类中静态成员变量和静态代码块\")]),s._v(\" \"),t(\"li\",[s._v(\"子类中静态成员变量和静态代码块\")]),s._v(\" \"),t(\"li\",[s._v(\"父类中普通成员变量和代码块，父类的构造函数\")]),s._v(\" \"),t(\"li\",[s._v(\"子类中普通成员变量和代码块，子类的构造函数\")])]),s._v(\" \"),t(\"p\",[s._v(\"总的来说，就是\"),t(\"strong\",[s._v(\"静态>非静态，父类>子类，非构造函数>构造函数\")]),s._v(\"。同一类别（例如普通变量和普通代码块）成员变量和代码块执行从前到后，需要注意逻辑。\")]),s._v(\" \"),t(\"p\",[s._v(\"这个也不难理解，静态变量也称类变量，可以看成一个全局变量，静态成员变量和静态代码块在类加载的时候就初始化，而非静态变量和代码块在对象创建的时候初始化。所以静态快于非静态初始化。\")]),s._v(\" \"),t(\"p\",[s._v(\"而在创建子类对象的时候需要先创建父类对象，所以父类优先于子类。\")]),s._v(\" \"),t(\"p\",[s._v(\"而在调用构造函数的时候，是对成员变量进行一些初始化操作，所以普通成员变量和代码块优于构造函数执行。\")]),s._v(\" \"),t(\"p\",[s._v(\"至于更深层次为什么这个顺序，就要更深入了解JVM执行流程啦。下面一个测试代码为：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v('class Father{\\n    public Father() {\\n        System.out.println(++b1+\"父类构造方法\");\\n    }//父类构造方法 第四\\n    static int a1=0;//父类static 第一 注意顺序\\n    static {\\n        System.out.println(++a1+\"父类static\");\\n    }\\n    int b1=a1;//父类成员变量和代码块 第三\\n    {\\n        System.out.println(++b1+\"父类代码块\");\\n    }\\n}\\nclass Son extends Father{\\n    public Son() {\\n        System.out.println(++b2+\"子类构造方法\");\\n    }//子类构造方法 第六\\n    static {//子类static第二步\\n        System.out.println(++a1+\"子类static\");\\n    }\\n    int b2=b1;//子类成员变量和代码块 第五\\n    {\\n        System.out.println(++b2 + \"子类代码块\");\\n    }\\n}\\npublic class test9 {\\n    public static void main(String[] args) {\\n        Son son=new Son();\\n    }\\n}\\n')])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"15\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"16\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"17\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"18\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"19\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"20\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"21\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"22\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"23\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"24\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"25\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"26\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"27\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"28\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"29\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"30\")]),t(\"br\")])]),t(\"p\",[s._v(\"执行结果：\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/webp/1158395/1606699861575-2d836b69-8320-495c-97d6-51fe68bb85b5.webp\",alt:\"image\"}})]),s._v(\" \"),t(\"h3\",{attrs:{id:\"三大特性-封装、继承、多态。最后问你能大致了解它们的特征嘛\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三大特性-封装、继承、多态。最后问你能大致了解它们的特征嘛\"}},[s._v(\"#\")]),s._v(\" 三大特性：封装、继承、多态。最后问你能大致了解它们的特征嘛？\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[s._v(\"封装\")]),s._v(\"：是对类的封装，封装是对类的属性和方法进行封装，只对外暴露方法而不暴露具体使用细节，所以我们一般设计类成员变量时候大多设为私有而通过一些get、set方法去读写。\")]),s._v(\" \"),t(\"li\",[t(\"strong\",[s._v(\"继承\")]),s._v(\"：子类继承父类，即“子承父业”，子类拥有父类除私有的所有属性和方法，自己还能在此基础上拓展自己新的属性和方法。主要目的是\"),t(\"strong\",[s._v(\"复用代码\")]),s._v(\"。\")]),s._v(\" \"),t(\"li\",[t(\"strong\",[s._v(\"多态\")]),s._v(\"：多态是同一个行为具有多个不同表现形式或形态的能力。即一个父类可能有若干子类，各子类实现父类方法有多种多样，调用父类方法时，父类引用变量指向不同子类实例而执行不同方法，这就是所谓父类方法是多态的。\")]),s._v(\" \"),t(\"li\",[s._v(\"最后送你一张图捋一捋其中的关系吧。\")])]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2020/png/1158395/1606700031459-d629ebf7-c72f-4b4d-96d3-f975ac3ee0c6.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"h4\",{attrs:{id:\"equals-方法重写之前比较的是对象的引用地址值-默认-重写后比较的是对象实体内容是否相等\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#equals-方法重写之前比较的是对象的引用地址值-默认-重写后比较的是对象实体内容是否相等\"}},[s._v(\"#\")]),s._v(\" equals():方法重写之前比较的是对象的引用地址值(默认),重写后比较的是对象实体内容是否相等\")]),s._v(\" \"),t(\"h4\",{attrs:{id:\"对于基本数据类型来说-比较的是值是否相同-对于引用数据类型则比较的内存地址值是否相同\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对于基本数据类型来说-比较的是值是否相同-对于引用数据类型则比较的内存地址值是否相同\"}},[s._v(\"#\")]),s._v(\" ==:对于基本数据类型来说,比较的是值是否相同,对于引用数据类型则比较的内存地址值是否相同\")]),s._v(\" \"),t(\"h4\",{attrs:{id:\"tostring-方法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#tostring-方法\"}},[s._v(\"#\")]),s._v(\" toString()方法\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v('A a = new A();\\nSystem.out.println(a);//直接输出a,相当于直接调用a的toString()方法 \\n\\n//以下为println方法源码\\npublic void println(Object x) {\\n        String s = String.valueOf(x);\\n        synchronized (this) {\\n            print(s);\\n            newLine();\\n        }\\n    }\\n public static String valueOf(Object obj) {\\n        return (obj == null) ? \"null\" : obj.toString();//此处调用了obj的toString方法\\n }\\n')])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"13\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"14\")]),t(\"br\")])]),t(\"h1\",{attrs:{id:\"六-包装类的使用\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#六-包装类的使用\"}},[s._v(\"#\")]),s._v(\" 六.包装类的使用\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"针对八种数据类型定义响应的引用类型-包装类\")]),s._v(\" \"),t(\"li\",[s._v(\"有了类的特点,就可以调用类中的方法,Java才是真正的面向对象\")])]),s._v(\" \"),t(\"table\",[t(\"thead\",[t(\"tr\",[t(\"th\",[t(\"strong\",[s._v(\"基本数据类型\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"包装类\")])]),s._v(\" \"),t(\"th\",[t(\"strong\",[s._v(\"父类\")])])])]),s._v(\" \"),t(\"tbody\",[t(\"tr\",[t(\"td\",[s._v(\"byte\")]),s._v(\" \"),t(\"td\",[s._v(\"Byte\")]),s._v(\" \"),t(\"td\",[s._v(\"Number\")])]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"short\")]),s._v(\" \"),t(\"td\",[s._v(\"Short\")]),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"int\")]),s._v(\" \"),t(\"td\",[s._v(\"Integer\")]),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"long\")]),s._v(\" \"),t(\"td\",[s._v(\"Long\")]),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"float\")]),s._v(\" \"),t(\"td\",[s._v(\"Float\")]),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"double\")]),s._v(\" \"),t(\"td\",[s._v(\"Double\")]),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"boolean\")]),s._v(\" \"),t(\"td\",[s._v(\"Boolean\")]),s._v(\" \"),t(\"td\")]),s._v(\" \"),t(\"tr\",[t(\"td\",[s._v(\"char\")]),s._v(\" \"),t(\"td\",[s._v(\"Character\")]),s._v(\" \"),t(\"td\")])])]),s._v(\" \"),t(\"p\",[s._v(\"基本数据类型,包装类,Stirng类型相互转换\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"JDK1.5之后,基本数据类型和包装类会自动拆箱和自动装箱\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"Integer内部定义了缓存,从-128到127,如果缓存中,则每次拿到的都是相同的数值,地址值也是相同的\")])]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2021/png/1158395/1614090095443-85ebe5ba-f477-4b6b-970e-ab6e2bbe59af.png\",alt:\"image.png\"}})]),s._v(\" \"),t(\"h1\",{attrs:{id:\"七-关键字讲解\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#七-关键字讲解\"}},[s._v(\"#\")]),s._v(\" 七.关键字讲解\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"static\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#static\"}},[s._v(\"#\")]),s._v(\" static\")]),s._v(\" \"),t(\"p\",[s._v(\"类优先对象加载\")]),s._v(\" \"),t(\"p\",[s._v(\"可以用来修饰\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"_1-属性和方法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-属性和方法\"}},[s._v(\"#\")]),s._v(\" 1. 属性和方法\")]),s._v(\" \"),t(\"h4\",{attrs:{id:\"属性-2\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#属性-2\"}},[s._v(\"#\")]),s._v(\" 属性\")]),s._v(\" \"),t(\"p\",[s._v(\"按照是否被static修改,又分为:静态属性 和 非静态属性(实例变量)\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"实例变量\")]),s._v(\":我们创建类的多个对象,每个对象都独立的拥有一套类中的非静态属性,当修改其中一个非静态属性    时,不会导致其他对象中的相同的的非静态属性值修改\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"静态变量\")]),s._v(\":我们创建了类的多个对象,多个对象共享同一个静态变量,当通过某一个对象修改静态变量时,会导致其他对象调用此静态属性的值被修改\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"其他说明\")]),s._v(\":\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"ul\",[t(\"li\",[s._v('静态变量随着类的加载而加载,可以通过\"类.静态变量\"的方式去调用')]),s._v(\" \"),t(\"li\",[s._v(\"静态变量加载早于对象的创建\")]),s._v(\" \"),t(\"li\",[s._v(\"由于类只会加载一次,则静态变量在内存中也只会加载一份,存在于方法区的静态域中\")])])])]),s._v(\" \"),t(\"h4\",{attrs:{id:\"方法-静态方法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#方法-静态方法\"}},[s._v(\"#\")]),s._v(\" 方法-静态方法\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v('随着类的加载而加载,可以通过\"类名.静态方法\"的方式去调用')]),s._v(\" \"),t(\"li\",[s._v(\"静态方法中只能调用静态的方法和静态属性\")]),s._v(\" \"),t(\"li\",[s._v(\"非静态方法既可以调用非静态的方法和属性,也可以调用静态的方法和属性-可以从类的声明周期去理解\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"_2-代码块\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-代码块\"}},[s._v(\"#\")]),s._v(\" 2. 代码块\")]),s._v(\" \"),t(\"p\",[s._v(\"用来初始化类或者是对象\")]),s._v(\" \"),t(\"p\",[s._v(\"代码块如果有修饰符的话只能是static\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"静态代码块:\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"ul\",[t(\"li\",[s._v(\"随着类的加载而执行,而且只会执行一次\")]),s._v(\" \"),t(\"li\",[s._v(\"作用:可以初始化类的信息\")]),s._v(\" \"),t(\"li\",[s._v(\"如果一个类中定义多个静态代码块,则按照定义的先后顺序执行\")]),s._v(\" \"),t(\"li\",[s._v(\"静态代码块优先于非静态代码块执行\")]),s._v(\" \"),t(\"li\",[s._v(\"静态代码块内部只可以调用静态方法和属性\")])])])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"非静态代码块:\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"ul\",[t(\"li\",[s._v(\"随着对象的创建而执行\")]),s._v(\" \"),t(\"li\",[s._v(\"每创建一个对象,就执行一次非静态代码块\")]),s._v(\" \"),t(\"li\",[s._v(\"作用:在创建对象时,可以对对象的属性等进行赋值\")]),s._v(\" \"),t(\"li\",[s._v(\"如果一个类中定义多个非静态代码块,则按照定义的先后顺序执行\")]),s._v(\" \"),t(\"li\",[s._v(\"非静态代码块内部,既可以调用静态方法和属性,也可以调用非静态方法和属性\")])])])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"_3-内部类\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-内部类\"}},[s._v(\"#\")]),s._v(\" 3. 内部类\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"final\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#final\"}},[s._v(\"#\")]),s._v(\" final\")]),s._v(\" \"),t(\"p\",[s._v(\"可以用来修饰:\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"类:表示该类不能被其他类继承\")]),s._v(\" \"),t(\"li\",[s._v(\"方法:表示该方法不能被重写\")]),s._v(\" \"),t(\"li\",[s._v(\"变量:此时的变量是一个常量,不允许被改变\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"修饰属性\")]),s._v(\":赋值位置是以下位置\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"ul\",[t(\"li\",[t(\"ul\",[t(\"li\",[s._v(\"必须显示初始化\")]),s._v(\" \"),t(\"li\",[s._v(\"代码块中初始化\")]),s._v(\" \"),t(\"li\",[s._v(\"构造器中初始化\")])])])])])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"修饰局部变量\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"ul\",[t(\"li\",[t(\"ul\",[t(\"li\",[s._v(\"修饰形参时,表明此形参是一个常量,给形参赋值实参,方法内部只允许调用,不允许重新赋值\")])])])])])]),s._v(\" \"),t(\"h2\",{attrs:{id:\"native\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#native\"}},[s._v(\"#\")]),s._v(\" native\")]),s._v(\" \"),t(\"p\",[s._v(\"被该修饰符修饰的方法表示此方法是底层的方法,C或C++的方法,java层面看不到该方法的具体实细节\")]),s._v(\" \"),t(\"h1\",{attrs:{id:\"八-抽象类-接口\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#八-抽象类-接口\"}},[s._v(\"#\")]),s._v(\" 八.抽象类  接口\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"抽象类\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#抽象类\"}},[s._v(\"#\")]),s._v(\" 抽象类\")]),s._v(\" \"),t(\"ol\",[t(\"li\",[s._v(\"被abstract修饰的类被称为抽象类\")]),s._v(\" \"),t(\"li\",[s._v(\"abstract既可以修饰类,也可以修饰方法\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"abstract修饰类:抽象类\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"此类不可以实例化\")]),s._v(\" \"),t(\"li\",[s._v(\"抽象类中一定有构造器,便于子类实例化去调用(子类对象初始化的全过程)\")]),s._v(\" \"),t(\"li\",[s._v(\"开发中,都会提供抽象类的子类,让子类对象实例化,完成相关的操作\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"abstract修饰方法:抽象方法\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"抽象方法只有方法的声明,没有方法体\")]),s._v(\" \"),t(\"li\",[s._v(\"包含抽象方法的类一定是抽象类,反之,抽象类里面可以没有抽象方法\")]),s._v(\" \"),t(\"li\",[s._v(\"若子类重写了父类的所有的抽象方法以后,则此子类方可实例化,反之,该子类也必须是抽象\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"使用注意点:\")])]),s._v(\" \"),t(\"p\",[s._v(\"不能修饰属性,构造器,代码块等结构\")]),s._v(\" \"),t(\"p\",[s._v(\"不能用来修饰私有方法,静态方法,还有final的方法,final的类\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"接口\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#接口\"}},[s._v(\"#\")]),s._v(\" 接口\")]),s._v(\" \"),t(\"ol\",[t(\"li\",[s._v(\"使用interface来定义\")]),s._v(\" \"),t(\"li\",[s._v(\"在Java中,接口和类是并列的结构\")]),s._v(\" \"),t(\"li\",[s._v(\"定义接口中的成员:\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"JDK7及以前:只能定义全局常量和抽象方法\")])]),s._v(\" \"),t(\"p\",[s._v(\">全局常量:public static final的,书写时可以省略不写\")]),s._v(\" \"),t(\"p\",[s._v(\">抽象方法:public abstract\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"JDK8:除了定义全局常量和抽象方法之外,还可以定义静态方法,默认方法\")])]),s._v(\" \"),t(\"p\",[s._v(\">接口中定义的静态方法,只能通过接口来调用\")]),s._v(\" \"),t(\"p\",[s._v(\">通过实现类对象,可以直接调用接口中的默认方法\")]),s._v(\" \"),t(\"p\",[s._v(\">如果子类(实现类)继承的父类和实现的接口中声明了同名同参数的方法,那么子类在没有重写此方法的情况 下,默认调用的是父类中的同名同参数的方法, --类优先原则\")]),s._v(\" \"),t(\"p\",[s._v(\"4.接口中不能定义构造器,意味接口不能实例化\")]),s._v(\" \"),t(\"p\",[s._v(\"5.Java可以实现多个接口,弥补了Java的单继承性的局限性\")]),s._v(\" \"),t(\"p\",[s._v(\"6.接口与接口之间可以多继承\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"内部类\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#内部类\"}},[s._v(\"#\")]),s._v(\" 内部类\")]),s._v(\" \"),t(\"p\",[s._v(\"Java中允许将一个类的A声明在另一个类B中,则类A就是内部类,类B称为外部类\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"内部类的分类:\")])]),s._v(\" \"),t(\"p\",[s._v(\"成员内部类:成员变量的位置,又分为静态的和非静态的\")]),s._v(\" \"),t(\"p\",[s._v(\"局部内部类:方法内,代码块内,构造器内\")]),s._v(\" \"),t(\"h1\",{attrs:{id:\"九-异常处理\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#九-异常处理\"}},[s._v(\"#\")]),s._v(\" 九.异常处理\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"异常简介\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#异常简介\"}},[s._v(\"#\")]),s._v(\" 异常简介\")]),s._v(\" \"),t(\"p\",[s._v(\"在 Java 中，所有的异常都有一个共同的祖先 \"),t(\"code\",[s._v(\"java.lang\")]),s._v(\" 包中的 \"),t(\"code\",[s._v(\"Throwable\")]),s._v(\" 类。\"),t(\"code\",[s._v(\"Throwable\")]),s._v(\" 类有两个重要的子类 \"),t(\"code\",[s._v(\"Exception\")]),s._v(\"（异常）和 \"),t(\"code\",[s._v(\"Error\")]),s._v(\"（错误）。\"),t(\"code\",[s._v(\"Exception\")]),s._v(\" 能被程序本身处理(\"),t(\"code\",[s._v(\"try-catch\")]),s._v(\")， \"),t(\"code\",[s._v(\"Error\")]),s._v(\" 是无法处理的(只能尽量避免)。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[t(\"code\",[s._v(\"Exception\")])]),s._v(\" 和 \"),t(\"code\",[s._v(\"Error\")]),s._v(\" 二者都是 Java 异常处理的重要子类，各自都包含大量子类。\")]),s._v(\" \"),t(\"p\",[s._v(\"**\"),t(\"code\",[s._v(\"Exception（异常）：\")]),s._v(\"**其他因编程错误或偶然的外在因素导致的一般性问题,可以使用针对性的代码进行处理,比如空指针,数组越界,程序本身可以处理的异常，可以通过 \"),t(\"code\",[s._v(\"catch\")]),s._v(\" 来进行捕获。\"),t(\"code\",[s._v(\"Exception\")]),s._v(\" 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[t(\"code\",[s._v(\"Error（错误）：\")]),s._v(\"****Java\")]),s._v(\"虚拟机无法解决的严重问题，属于程序无法处理的错误 ，我们没办法通过 \"),t(\"code\",[s._v(\"catch\")]),s._v(\" 来进行捕获，比如OOM。\")]),s._v(\" \"),t(\"p\",[s._v(\"**\\n**\")]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2021/png/1158395/1615254585549-7e8cf832-33ef-47ae-a387-d546a997d83c.png\",alt:\"Java异常类层次结构图.png\"}})]),s._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://cdn.nlark.com/yuque/0/2021/png/1158395/1615254610601-b8357f80-a4b3-4c42-b1db-9deb7a2eb3c1.png?x-oss-process=image%2Fresize%2Cw_1500\",alt:\"Java异常类层次结构图2.png\"}})]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"受检查异常(编译时异常) -Checked\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"执行javac.exe命令时，可能出现的异常\")]),s._v(\" \"),t(\"li\",[s._v(\"Java 代码在编译过程中，如果受检查异常没有被 \"),t(\"code\",[s._v(\"catch\")]),s._v(\"/\"),t(\"code\",[s._v(\"throw\")]),s._v(\" 处理的话，就没办法通过编译。\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"非受检查异常（运行时异常）-Un-Checked\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"执行java。exe命令时，出现的异常\")]),s._v(\" \"),t(\"li\",[s._v(\"Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。\")])]),s._v(\" \"),t(\"p\",[t(\"code\",[s._v(\"RuntimeException\")]),s._v(\" 及其子类都统称为非受检查异常，例如：\"),t(\"code\",[s._v(\"NullPointerException\")]),s._v(\"、\"),t(\"code\",[s._v(\"NumberFormatException\")]),s._v(\"（字符串转换为数字）、\"),t(\"code\",[s._v(\"ArrayIndexOutOfBoundsException\")]),s._v(\"（数组越界）、\"),t(\"code\",[s._v(\"ClassCastException\")]),s._v(\"（类型转换错误）、\"),t(\"code\",[s._v(\"ArithmeticException\")]),s._v(\"（算术错误）等。\")]),s._v(\" \"),t(\"h2\",{attrs:{id:\"异常处理-抓抛模型\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#异常处理-抓抛模型\"}},[s._v(\"#\")]),s._v(\" 异常处理（抓抛模型）\")]),s._v(\" \"),t(\"h3\",{attrs:{id:\"方式一-try-catch-finally-抓\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#方式一-try-catch-finally-抓\"}},[s._v(\"#\")]),s._v(\" 方式一：try-catch-finally（抓）\")]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[t(\"code\",[s._v(\"try\")]),s._v(\"块：\")]),s._v(\" 用于捕获异常，可能出现异常的代码。其后可接零个或多个 \"),t(\"code\",[s._v(\"catch\")]),s._v(\" 块，如果没有 \"),t(\"code\",[s._v(\"catch\")]),s._v(\" 块，则必须跟一个 \"),t(\"code\",[s._v(\"finally\")]),s._v(\" 块。\")]),s._v(\" \"),t(\"li\",[t(\"strong\",[t(\"code\",[s._v(\"catch\")]),s._v(\"块：\")]),s._v(\" 用于处理 try 捕获到的异常，一旦处理完成，就跳出了当前的catch结构，多个catch时，匹配哪个catch，就跳出那个\")]),s._v(\" \"),t(\"li\",[t(\"strong\",[t(\"code\",[s._v(\"finally\")]),s._v(\" 块：\")]),s._v(\" 可选的，无论是否捕获或处理异常，\"),t(\"code\",[s._v(\"finally\")]),s._v(\" 块里的语句都会被执行。当在 \"),t(\"code\",[s._v(\"try\")]),s._v(\" 块或 \"),t(\"code\",[s._v(\"catch\")]),s._v(\" 块中遇到 \"),t(\"code\",[s._v(\"return\")]),s._v(\" 语句时，\"),t(\"code\",[s._v(\"finally\")]),s._v(\" 语句块将在 方法返回之前被执行。\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"在以下 3 种特殊情况下，\"),t(\"code\",[s._v(\"finally\")]),s._v(\" 块不会被执行：\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"在 \"),t(\"code\",[s._v(\"try\")]),s._v(\" 或 \"),t(\"code\",[s._v(\"finally\")]),s._v(\"块中用了 \"),t(\"code\",[s._v(\"System.exit(int)\")]),s._v(\"退出程序。但是，如果 \"),t(\"code\",[s._v(\"System.exit(int)\")]),s._v(\" 在异常语句之后，\"),t(\"code\",[s._v(\"finally\")]),s._v(\" 还是会被执行\")]),s._v(\" \"),t(\"li\",[s._v(\"程序所在的线程死亡\")]),s._v(\" \"),t(\"li\",[s._v(\"关闭 CPU\")])]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"注意：\")]),s._v(\" 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：\")]),s._v(\" \"),t(\"div\",{staticClass:\"language- line-numbers-mode\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[s._v(\"public class Test {\\n    public static int f(int value) {\\n        try {\\n            return value * value;\\n        } finally {\\n            if (value == 2) {\\n                return 0;\\n            }\\n        }\\n    }\\n}\\n//如果调用 f(2)，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。\\n\")])]),s._v(\" \"),t(\"div\",{staticClass:\"line-numbers-wrapper\"},[t(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"10\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"11\")]),t(\"br\"),t(\"span\",{staticClass:\"line-number\"},[s._v(\"12\")]),t(\"br\")])]),t(\"h3\",{attrs:{id:\"方式二-throws-异常对象-抛\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#方式二-throws-异常对象-抛\"}},[s._v(\"#\")]),s._v(\" 方式二： throws + 异常对象（抛）：\")]),s._v(\" \"),t(\"p\",[s._v(\"程序在正常执行过程中，一旦出现异常，就会在异常代码块处生成一个对应的异常类对象，，并将此对象抛出。一旦抛出对象后，其后的代码将不再执行\")]),s._v(\" \"),t(\"p\",[s._v('\"throws + 异常对象\" 写在方法声明处，指明此方法执行时，可能会抛出异常类型')]),s._v(\" \"),t(\"p\",[s._v(\"也可以在方法处手动生成异常：throw new Exception();\")]),s._v(\" \"),t(\"p\",[t(\"strong\",[s._v(\"总结\")])]),s._v(\" \"),t(\"ul\",[t(\"li\",[s._v(\"throws代表有可能会发生异常，throw代表一定会有异常\")]),s._v(\" \"),t(\"li\",[s._v(\"使用try-catch-finally处理编译时异常时，使得程序在编译时就不再报错，但是运行时仍可能报错，相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到了运行时出现\")]),s._v(\" \"),t(\"li\",[s._v(\"开发中，由于运行时异常比较常见，所以我们通常不针对运行时异常编写try-catch-finally了，针对编译时异常，我们一定要考虑异常的处理\")]),s._v(\" \"),t(\"li\",[s._v(\"try-catch-finally是真正将异常处理掉了，throws的方式只是将异常给了方法的调用者，并没有真正将异常处理掉。\")]),s._v(\" \"),t(\"li\",[s._v(\"子类重写的方法抛出的异常类型不大于父类被重写方法抛出的类型\")])]),s._v(\" \"),t(\"h3\",{attrs:{id:\"throwable-类常用方法\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#throwable-类常用方法\"}},[s._v(\"#\")]),s._v(\" \"),t(\"a\",{attrs:{href:\"https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_322-throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\",target:\"_blank\",rel:\"noopener noreferrer\"}},[s._v(\"Throwable 类常用方法\"),t(\"OutboundLink\")],1)]),s._v(\" \"),t(\"ul\",[t(\"li\",[t(\"strong\",[t(\"code\",[s._v(\"public string getMessage()\")])]),s._v(\":返回异常发生时的简要描述\")]),s._v(\" \"),t(\"li\",[t(\"strong\",[t(\"code\",[s._v(\"public string toString()\")])]),s._v(\":返回异常发生时的详细信息\")]),s._v(\" \"),t(\"li\",[t(\"strong\",[t(\"code\",[s._v(\"public string getLocalizedMessage()\")])]),s._v(\":返回异常对象的本地化信息。使用 \"),t(\"code\",[s._v(\"Throwable\")]),s._v(\" 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 \"),t(\"code\",[s._v(\"getMessage（）\")]),s._v(\"返回的结果相同\")]),s._v(\" \"),t(\"li\",[t(\"strong\",[t(\"code\",[s._v(\"public void printStackTrace()\")])]),s._v(\":在控制台上打印 \"),t(\"code\",[s._v(\"Throwable\")]),s._v(\" 对象封装的异常信息\")])])])}),[],!1,null,null,null);a.default=v.exports}}]);","extractedComments":[]}